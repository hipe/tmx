# introduction

    Invocation__
      ^    ^
      |     \--------------- Action_Adapter_
      |                           \
    Branch_Invocation__            \
      ^            ^                \----->  Adapter_Methods__
      |             \                        ^
      |              \                      /
    Top_Invocation__  \----- Branch_Adapter__

    (see also the sibling dotfile "class-digraph.dot")


This model grew out of literally years of rewrites.

the first node created is the top client. the main function of this node
is to resolve one of many child nodes to field the request. the top
client will dispatch the well-formed request to one of its children.
this child will be a leaf node or a branch node. when branch node this
process will be repeated recursively until a leaf ("terminal") node is
resolved.

the top node and the non-top branch nodes are similar but not the same.
the top node is like a non-top branch node with some added
responsibility and public API methods. likewise the non-top branch node
will have behavior that is differnt than the top node, namely that the
former has a parent and the latter does not.

leaf nodes always have parents and never have children hence they are
different from the other two kinds of nodes discussed so far. however
all three have behavior in common, namely that they all parse options
and output help screens, to naame a few.

hence, 'invocation' is the abstract base class to rule them all. 'branch
invocation' is yet another abstract base class childing off the first,
that implements the branch-specific behavior. the top client and the
non-top branch nodes each have their own class childing from that.

for the terminal (leaf) nodes, we have yet another concrete class
childing from the basest base class. since the "concrete" leaf and
branch nodes both have some behavior that is common to them but not the
top node, this behavior is put into a ("mixin") module.

it's that simple.




## :#note-075

for the lazy. every action invocation may trigger multiple events, but
can only result in one exit status. we derive the exit status from the
events. how to reconcile the two is the subject of this soliloquy:

it may be that we set an exit status with each of several polarized events
we receive (events where `ok` has been set to true or false). if
this is the case, what are we to do if we once set an exit status to be
some error code, and then subsequently set it to be 0 (success)? or if we
once set it to be one error code, and then later set it to another?

our "meh" solution for now is that in the case of collision, we
effectively allow the exit status (or perhaps more fittingly "error level")
to be increased but not decreased. at best it will prevent us from masking an
error with a subsequent success. at worst it will mask less specific
errors with more specific errors.

but the bottom line is, if a client needs more precise control of what
the exit status is, relying on inferred exit statii is not the way to do
it. and because exit statii are the domain of CLI (and perhaps some
arcane sort of API), and these are conceived of as modalities, precise
control of exit statii is then beyond the scope of this project, whose
goal is to generate modality-specific interfaces as a byproduct of the
model and its behavior.

to put it another way, if we can't find a meaningful and direct
isomorphicism from model state to interface state, then we don't really
care about it.

the reason we use `instance_variable_defined?` instead of setting the
exit status ivar to nil in the initialize method is so that it is left
unset so we can more easily track when & where we fail to set it.





## :#note-165

the implementor may in her top adapter class (usually called `CLI`)
create a module called `Actions` and provide appropriately named clases
for any actions that she wants to customize (the actions in this tree
must be a subset of the tree generated by the kernel (typically
generated from the `Models_` node). not to do so is undefined.)

currently the only known reason to do this is to catch particular
events emitted by the corresponding upstream API action, and handle
them differently than the default behavior provided by this modality
package.

with brazen more so than its predecessor frameworks this sort of
customization is for now "strongly discouraged" unless it is for
exploratory purposes towards some kind of [#021] magical behavior.


so anyway, this frozen module called `Actions` here is the
end-of-the-line base case module that is found for the frequent caes of
the application not having any customization at this node.




## :#note-575


experimental aesthetics - when there is nothing filling the
trailing optional arg "slot", let a would-be option fill this spot.


the general trend here is to try to get properties out of the options
and into the arguments if possible. it looks nicer and reads more
cleanly, and is a fun and silly challenge.

(a) if we mucked around with globbing arguments already, then don't
bother here. you can have multiple trailing or leading optionals (a structure
we will never produce here) but you can't have one 'many' argument in
conjunction with any other non-one-aritied arguments.

(b) when there are as yet no args at all, we have nothing to lose by
putting one of the opts into the last "slot" of the args.

(c) even if there are alreay args there, we assume that none of them are
already globbing or optional, because otherwise they would have been handled
by the "many" logic earlier, or not fallen into the arg list in the
first place because the qualifier for this list is that the property is
"actually required". in such cases EXPERIMENTALLY we go ahead
and make the transformation to put the last option in with the args as a
trailing optional.




## :#note-600

sadly we still have some cases to filter out. in the cases where
properties are actually "officious" options (things like --version and
--help, actually more like actions than options); we don't want these to
become arguments. this could stand to be improved.
