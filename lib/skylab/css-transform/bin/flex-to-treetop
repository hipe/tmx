#!/usr/bin/env ruby
require 'optparse'
require 'pp'
require 'strscan'
require 'rubygems'
# require 'ruby-debug'; puts "\e[1;5;33mruby-debug\e[0m"
require 'treetop'

# Test with:
# bundle exec bin/flex-to-treetop test/fixtures/flex/ideal.flex

# The structure of this file is ridiculous because we're trying to keep it all
# in one file as a standalone thing.  It is, in sequence:
#   0) Sexpesque and CommonNode* and AutoNode* abstraction candidates
#   1) a Cli class to parse commands 2) FlexToTreetop that is the main agent
#   3) Pull in the treetop-generated parser (by one of a variety of ways)
#   4) Subclass it (MyFlexFileParser < FlexFileParser) 5) run this file
#   6) The treetop grammar in put inline after the __END__ for novelty points.

module Hipe
  module FlexToTreetop
    VERSION = '0.0.0'
  end
end

class Hipe::FlexToTreetop::Sexpesque < Array
  class << self
    def traditional name, *rest
      new(name, *rest)
    end
    def hashy name, hash
      new(name, hash)
    end
    def node_name n=nil
      n.nil? ? @node_name : (@node_name = n)
    end
    def list list
      traditional(node_name, *list)
    end
  end
  def initialize name, *rest
    super([name, *rest])
  end
end

module Hipe::FlexToTreetop::CommonNodey
  Sexpesque = ::Hipe::FlexToTreetop::Sexpesque
  def at(str); ats(str).first end
  def ats path
    path = at_compile(path) if path.kind_of?(String)
    here = path.first
    cx = (here == '*') ? elements : (elements[here] ? [elements[here]] : [])
    if path.size > 1 && cx.any?
      child_path = path[1..-1]
      cx = cx.map do |c|
        if ! c.respond_to?(:ats)
          c.extend(::Hipe::FlexToTreetop::CommonNodey)
        end
        c.ats(child_path)
      end.flatten
    end
    cx
  end
  def at_compile str
    res = []
    s = StringScanner.new(str)
    begin
      if s.scan(/\*/)
        res.push '*'
      elsif s.scan(/\[/)
        d = s.scan(/\d+/) or fail("expecting digit had #{s.rest.inspect}")
        s.scan(/\]/) or fail("expecting ']' had #{s.rest.inspect}")
        res.push d.to_i
      else
        fail("expecting '*' or '[' near #{s.rest.inspect}")
      end
    end until s.eos?
    res
  end
  def sexp_at str
    # (n = at(str)) ? n.sexp : nil
    n = at(str)
    n or return nil
    n.respond_to?(:sexp) and return n.sexp
    n.text_value == '' and return nil
    debugger; 'where is sexp for n'
  end
  def sexps_at str
    ats(str).map(&:sexp)
  end
  def composite_sexp my_name, *children
    with_names = {}
    children.each do |name|
      got = send(name)
      sexp =
        if got.respond_to?(:sexp)
          got.sexp
        else
          debugger; 'why does "got" have no sexp'
          :no
        end
      with_names[name] = sexp
    end
    return Sexpesque.hashy(my_name, with_names)
  end
  def list_sexp *foos
    foos.compact!
    foos # yeah, that's all this does
  end
  def auto_sexp *a
    name = a.any? ? a.shift : guess_node_name
    Sexpesque.traditional(name, text_value)
  end
  def guess_node_name
    m = singleton_class.ancestors.first.to_s.match(/([^:0-9]+)\d+$/)
    if m
      m[1].gsub(/([a-z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern
    else
      debugger; 'x'
    end
  end
  def singleton_class
    @sc ||= class << self; self end
  end
end

module Hipe::FlexToTreetop
  class CommonNode < ::Treetop::Runtime::SyntaxNode
    include CommonNodey
  end
  module AutoNodey
    include CommonNodey
    def sexp; auto_sexp end
  end
  class AutoNode < CommonNode
    include AutoNodey
  end
end

module Hipe::FlexToTreetop
  class PatternChoiceSexp < Sexpesque
    node_name :pattern_choice
  end
  class PatternSequenceSexp < Sexpesque
    node_name :pattern_sequence
  end
  class UseDefinitionSexp < Sexpesque
    node_name :use_definition
  end
end

module Hipe::FlexToTreetop

  class << self
    def cli
      @cli ||= Cli.new
    end
  end
  class Cli
    def initialize
      @err = $stderr
      @out = $stdout
      @in =  $stdin
      @conf = {}
    end
    def out *a
      @out.puts(*a)
    end
    def err *a
      @err.puts(*a)
    end
    def run argv
      begin
        option_parser.parse!(argv)
        if @actions
          if ! @in.tty?
            usage "can't read from STDIN when doing "+
              @actions.map(&:to_s).join(' ')
          else
            resp = nil
            @actions.each{ |meth| resp = send(meth) }
            resp
          end
        elsif @in.tty?
          if @tempfile_loaded && argv.empty? # allowed for parse checks
            err 'No file arguments present.  Done.'
          elsif argv.size != 1
            usage "expecting <flexfile> had: (#{argv.join(' ')})"
          else
            if ! File.exist?(infile = argv.shift)
              usage "<flexfile> not found: #{infile}"
            else
              infh = File.open(infile, 'r')
              _run(infh)
            end
          end
        else
          if argv.size != 0
            usage "reading STDIN as <flexfile>, had: (#{argv.join(' ')})"
          else
            _run(@in)
          end
        end
      rescue ::OptionParser::InvalidOption => e
        usage e.message
      end
    end
    # we have to parse it ourselves because OptionParser doesn't allow partial
    def parse_tempfile_option argv
      have = argv.each_with_index.map do |v,i|
        (m = /^(?:-t(.*)|--tempdir(?:=(.+))?)$/.match(v) ) ?
          [m.captures,i] : nil
      end.compact
      case have.size
        when 0 ; return
        when 1 ;
        else   ; return fatal("cannot process more than one --tempdir option")
      end
      pair = have.first
      argv[pair[1]] = nil # probably not necessary
      pair.first.detect{ |x| x } || ""
    end
    def process_tempfile_option argv
      tempdir = parse_tempfile_option(argv) or return
      clear = false
      argv.each_with_index do |v, idx|
        if ['-c', '--clear'].include?(v)
          clear = true
          argv[idx] = nil
        end
      end
      argv.compact!
      if "" == tempdir
        require 'tmpdir'
        tempdir = Dir.tmpdir
      end
      treetop_path = File.join(tempdir, 'flex-to-treetop.treetop')
      parser_path  = File.join(tempdir, 'flex-to-treetop.rb')
      if clear
        require 'fileutils'
        [treetop_path, parser_path].each do |path|
          if File.exist?(path)
            FileUtils.rm(path, :verbose => true)
          end
        end
      end
      if File.exist?(parser_path)
        err "Using parser from filesystem: #{parser_path}"
      else
        if ! File.exist?(treetop_path)
          @err.write "Writing grammar file: #{treetop_path}"
          if ! File.directory?(File.dirname(treetop_path))
            return fatal("\nNot a directory: #{File.dirname(treetop_path)}")
          end
          b = nil
          File.open(treetop_path, 'w+'){ |fh| b = fh.write(TreetopGrammar) }
          @err.puts " (wrote #{b} bytes.)"
        end
        if "" == %x{which tt}
          return fatal(
            "`tt` command not found! Is treetop gem installed and in PATH?"
          )
        end
        @err.puts("executing: " + (cmd = "tt #{treetop_path}"))
        res = %x{#{cmd}}
        if "" != res then @err.puts(res) end
      end
      if File.exist? parser_path
        require parser_path
      else
        err "Parser file not found: #{parser_path}"
      end
      @tempfile_loaded = true
    end
  private
    def fatal msg
      err msg
      exit(1)
    end
    def help_string
      option_parser.to_s
    end
    def option_parser
      @option_parser and return @option_parser
      o = OptionParser.new
      o.banner = "Usage: #{program_name} [options] <flexfile>"

      o.on('-g', '--grammar',
       '(debugging) Show the flex treetop grammar as it appears in this file.'
      ) { self.action = :grammar }

      o.on('-t[=<dir>]', '--tempdir[=<dir>]',
        '(debugging) Write/Read flex treetop grammar from the filesystem.'
      ) { }

      o.on('-c', '--clear',
        "If using --tempdir, clear existing files first."
      ) { }

      o.on('-h', '--help', 'Show this message') { self.action = :help }
      o.on('-v', '--version', 'Show Version') { self.action = :version }

      @option_parser = o
    end

    def program_name
      File.basename($PROGRAM_NAME)
    end

    def action= name
      @actions ||= []
      @actions.push name
    end

    def grammar
      out TreetopGrammar
    end

    def version
      err "#{program_name} version #{VERSION}"
    end

    def help
      err help_string
    end

    def _run in_io
      FlexToTreetop.new(in_io, @out, @err, @config).run
    end

    def usage msg
      err msg
      err help_string
    end
  end
  class FlexToTreetop
    @@loaded = false
    def initialize instream, outstream, errstream, config
      @in = instream; @out = outstream; @err = errstream; @conf = config
    end
    def run
      p = parser
      whole_file = @in.read
      @in.close
      resp = p.parse(whole_file)
      if resp.nil?
        rsn = p.failure_reason || "Got nil from parse without reason!"
        @err.puts rsn
      else
        PP.pp resp.sexp
      end
    end
  private
    def parser
      @parser ||= MyFlexFileParser.new
    end
  end
end

run = File.basename(__FILE__) == File.basename($PROGRAM_NAME)
cli = Hipe::FlexToTreetop.cli if run

Hipe::FlexToTreetop::TreetopGrammar = DATA.read

if run && ! cli.process_tempfile_option(ARGV)
  ::Treetop.load_from_string Hipe::FlexToTreetop::TreetopGrammar
end

if ! Hipe::FlexToTreetop.const_defined?(:FlexFileParser)
  Hipe::FlexToTreetop.cli.err "Hipe::FlexToTreetop::FlexFileParser not found!"
else

module Hipe::FlexToTreetop
  class MyFlexFileParser < FlexFileParser # gen'd by treetop, see FlexFile

    # CompiledParser#failure_reason overridden for less context
    def failure_reason
      return nil unless (tf = terminal_failures) && tf.size > 0
      "Expected " +
        ( tf.size == 1 ?
          tf[0].expected_string.inspect :
          "one of #{tf.map{|f| f.expected_string.inspect}.uniq*', '}"
        ) + " at line #{failure_line}, column #{failure_column} " +
        "(byte #{failure_index+1}) after#{my_input_excerpt}"
    end

    def num_lines_ctx; 4 end

    def my_input_excerpt
      num = num_lines_ctx
      slicey = input[index...failure_index]
      all_lines = slicey.split("\n", -1)
      lines = all_lines.slice(-1 * [all_lines.size, num].min, all_lines.size)
      nums = failure_line.downto(
        [1, failure_line - num + 1].max).to_a.reverse
      w = nums.last.to_s.size # greatest line no as string, how wide?
      ":\n" + nums.zip(lines).map do |no, line|
        ("%#{w}i" % no) + ": #{line}"
      end.join("\n")
    end
  end
end
end

if run then Hipe::FlexToTreetop.cli.run(ARGV) end

__END__
# The 'pattern' rule below is a subset of the grammar grammar described at
#   http://flex.sourceforge.net/manual/Patterns.html.
#   Note that not all constructs are supported, only those necessary
#   to parse the target flex input files.

module Hipe
module FlexToTreetop
grammar FlexFile
  rule file
    definitions spacey* '%%' spacey* rules spacey*  <CommonNode>
    { def sexp; composite_sexp :file, :definitions, :rules end }
  end
  rule definitions
    spacey*  ( definition_declaration (decl_sep definition_declaration)*  )?
    <CommonNode> {
      def sexp
        list_sexp(sexp_at('[1][0]'), * sexps_at('[1][1]*[1]'))
      end
    }
  end
  rule definition_declaration
    name_definition / start_declaration
  end
  rule name_definition
    name_definition_name [ \t]+ name_definition_definition
    <CommonNode> {
      def sexp
        composite_sexp(
          :name_definition, :name_definition_name, :name_definition_definition
        )
      end
    }
  end
  rule name_definition_name
    [A-Za-z_] [-a-zA-Z0-9_]* {
      def sexp
        text_value
      end
    }
  end
  rule name_definition_definition
    pattern
  end
  rule start_declaration
    '%' 'option' [ \t]+ 'case-insensitive'
     <CommonNode> {
      def sexp
        Sexpesque.hashy( :start_declaration,
          :declaration_type  => 'option',
          :declaration_value => 'case-insensitive'
        )
      end
    }
  end
  rule rules
    rool (decl_sep rool)* <CommonNode> {
      def sexp
        list_sexp(sexp_at('[0]'), *sexps_at('[1]*[1]'))
      end
    }
  end
  rule rool
    pattern [ \t]+ action <CommonNode> {
      def sexp
        composite_sexp(:rule, :pattern, :action)
      end
    }
  end
  rule pattern
    pattern_part pattern_part* ( '|' pattern )* <CommonNode> {
      def sexp
        seq = list_sexp(sexp_at('[0]'), * sexps_at('[1]*'))
        choice = sexps_at('[2]*[1]')
        seq_or_pat = seq.size == 1 ? seq.first : PatternSequenceSexp.list(seq)
        if choice.any?
          PatternChoiceSexp.list( [seq_or_pat] + choice )
        else
          seq_or_pat
        end
      end
    }
  end
  rule pattern_part
    ( character_class / string / use_definition / backslashes /
        dot / literal_char / parenthesized_group ) range?
    <CommonNode> {
      def sexp
        h = nil
        first = sexp_at('[0]')
        range = sexp_at('[1]') and h = {:range => range}
        Sexpesque.traditional(:pattern_part, first, h)
      end
    }
  end
  rule parenthesized_group
    '(' pattern ')' <AutoNode> { }
  end
  rule character_class
    '[' (!']' . / '\]')* ']' <AutoNode> { }
  end
  rule string
    '"' (!'"' . / '\"')* '"' <AutoNode> { }
  end
  rule use_definition
    '{' name_definition_name '}' <CommonNode> {
      def sexp
        UseDefinitionSexp.traditional(:use_definition, elements[1].text_value)
      end
    }
  end
  rule backslashes
    hex / octal / '\\0' / backslash_other
  end
  rule hex
    '\\x' [0-9A-Za-z]+ <AutoNode> { }
  end
  rule octal
    '\\' [1-9] [0-9]* <AutoNode> { }
  end
  rule action
    [^\n]+ <AutoNode> { }
  end
  rule backslash_other
    '\\' [^ \t\n\r\f] <AutoNode> { }
  end
  rule dot
    '.' <AutoNode> { }
  end
  rule literal_char
    [^\\|/\[\](){} \t\n\r\f] <AutoNode> { }
  end
  rule range
    ( '*' / '+' / '?' / ( '{' [0-9]+ ( ',' [0-9]* )? '}' ) ) <AutoNodey> { }
  end
  rule comment
    '/*' ( [^*] / '*' !'/' )* '*/' <AutoNode> { }
  end
  rule spacey
    comment / [ \t\n\f\r]
  end
  rule decl_sep
    ( [ \t] / comment )* newline spacey*
  end
  # http://en.wikipedia.org/wiki/Newline (near OSX)
  rule newline
    "\n" / "\r\n"
  end
end
end
end
