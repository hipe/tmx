#!/usr/bin/env ruby

require 'optparse'
require 'pp'
require 'rubygems'
require 'ruby-debug'
require 'treetop'


module Hipe; end

module Hipe::FlexToTreetop
  VERSION = '0.0.0'

  class << self
    def cli
      Cli.new
    end
  end
  class Cli
    def initialize
      @err = $stderr
      @out = $stdout
      @in =  $stdin
      @conf = {}
    end
    def run argv
      catch(:done) do
        begin
          option_parser.parse!(argv)
          if @in.tty?
            if argv.size != 1
              usage "expecting <flexfile> had: (#{argv.join(' ')})"
            else
              if ! File.exist?(infile = argv.shift)
                usage "<flexfile> not found: #{infile}"
              else
                infh = File.open(infile, 'r')
                _run(infh)
              end
            end
          else
            if argv.size != 0
              usage "reading STDIN as <flexfile>, had: (#{argv.join(' ')})"
            else
              _run(@in)
            end
          end
        rescue ::OptionParser::InvalidOption => e
          usage e.message
        end
      end
    end
  private
    def err *a
      @err.puts(*a)
    end
    def help_string
      option_parser.to_s
    end
    def out *a
      @out.puts(*a)
    end
    def option_parser
      @option_parser and return @option_parser
      o = OptionParser.new
      o.banner = "Usage: #{program_name} [options] <flexfile>"

      o.on('-h', '--help', 'Show this message') do
        err help_string
        throw :done
      end

      o.on('-v', '--version', 'Show Version') do
        err "#{program_name} version #{VERSION}"
        throw :done
      end
      @option_parser = o
    end

    def program_name
      File.basename($PROGRAM_NAME)
    end
    def _run in_io
      FlexToTreetop.new(in_io, @out, @err, @config).run
    end
    def usage msg
      err msg
      err help_string
    end
  end
  class FlexToTreetop
    @@loaded = false
    def initialize instream, outstream, errstream, config
      @in = instream; @out = outstream; @err = errstream; @conf = config
    end
    def run
      p = parser
      whole_file = @in.read
      @in.close
      resp = p.parse(whole_file)
      if resp.nil?
        @err.puts p.failure_reason
      else
        PP.pp resp
      end
    end
  private
    def parser
      @parser ||= MyFlexFileParser.new
    end
  end
end

# run the string defined after __END__ below thru treetop
::Treetop.load_from_string DATA.read

module Hipe::FlexToTreetop
  class MyFlexFileParser < FlexFileParser # gen'd by treetop, see FlexFile

    # CompiledParser#failure_reason overridden for less context
    def failure_reason
      return nil unless (tf = terminal_failures) && tf.size > 0
      "Expected " +
        ( tf.size == 1 ?
          tf[0].expected_string.inspect :
          "one of #{tf.map{|f| f.expected_string.inspect}.uniq*', '}"
        ) + " at line #{failure_line}, column #{failure_column} " +
        "(byte #{failure_index+1}) after#{my_input_excerpt}"
    end

    def num_lines_ctx; 4 end

    def my_input_excerpt
      num = num_lines_ctx
      slicey = input[index...failure_index]
      all_lines = slicey.split("\n", -1)
      lines = all_lines.slice(-1 * [all_lines.size, num].min, all_lines.size)
      nums = failure_line.downto(
        [1, failure_line - num + 1].max).to_a.reverse
      w = nums.last.to_s.size # greatest line no as string, how wide?
      ":\n" + nums.zip(lines).map do |no, line|
        ("%#{w}i" % no) + ": #{line}"
      end.join("\n")
    end
  end
end

if File.basename(__FILE__) == File.basename($PROGRAM_NAME)
  Hipe::FlexToTreetop.cli.run(ARGV)
end

__END__

module Hipe
module FlexToTreetop
grammar FlexFile
  rule file
    definitions '%%' rules
  end
  rule definitions
    anyspace? (definition_declaration ( &{ debugger; x=1; x } sepspace definition_declaration)*)?
  end
  rule definition_declaration
    name_definition / start_declaration
  end
  rule name_definition
    name_definition_name spc name_definition_definition
  end
  rule name_definition_name
    [A-Za-z_] [-a-zA-Z0-9_]*
  end
  rule name_definition_definition
    [^\n]+
  end
  rule start_declaration
    '%' 'option' [ \t]+ 'case-insensitive'
  end
  rule rules
    .+
  end
  rule anyspace
    (white / comment)+
  end
  rule sepspace
    anyspace? "\n" &{ debugger; x = 1; x }
  end
  rule comment
    '/*' ( [^*] / '*' !'/' )* '*/'
  end
  rule white
    [ \n\r\t\f]+
  end
  rule spc
    [ \t]+
  end
end
end
end
