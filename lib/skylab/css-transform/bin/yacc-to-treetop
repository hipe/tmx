#!/usr/bin/env ruby -w
require 'optparse'
require 'pp'
require 'strscan'
require 'rubygems'
require 'treetop'
# require 'ruby-debug'; $stderr.puts "\e[1;5;33mruby-debug\e[0m"

# test case 1: ./bin/yacc-to-treetop test/fixtures/yaccw3/selectors.yaccw3


module Hipe; end
module Hipe::YaccToTreetop
  VERSION = '0.0.0'
  class << self
    def cli; @cli ||= Cli.new end
  end

  class CliBase # experimental keep low level cli away from business logic
    def run argv
      @argv = argv
      @c = build_context
      @exit_ok = nil
      @queue = []
      begin
        option_parser.parse!(argv)
        @queue.push default_action
        catch(:early_exit){ @queue.each{ |meth| send meth } }
      rescue OptionParser::ParseError => e
        error e.message
      end
    end
  protected
    Codes = {:bold=>1,:dark_red=>31,:green=>32,:yellow=>33,:blue=>34,
      :purple=>35,:cyan=>36,:white=>37,:red=>38}
    def color(s, *a); "\e[#{a.map{|x|Codes[x]}.compact*';'}m#{s}\e[0m" end
    def em(s); color(s, :bold, :green) end

    def error msg
      @c.err.puts msg
      @c.err.puts usage
      @c.err.puts invite
    end
    def fatal msg
      @c.err.puts msg
      throw :early_exit
    end
    def invite
      em("#{program_name} -h") << " for help"
    end
    def run_help
      @c.err.puts option_parser.to_s
      @exit_ok = true
    end
    def run_version
      @c.err.puts "#{program_name} #{version_string}"
      @exit_ok = true
    end
    def usage
      "#{em('usage:')} #{usage_syntax_string}"
    end
  end

  class ExecutionContext < Hash
    def initialize
      @out = $stdout
      @err = $stderr
    end
    attr_reader :out, :err
    attr_accessor :in
  end

  class Cli < CliBase
  private
    def build_context;        ExecutionContext.new                         end
    def default_action;       :run_translate                               end
    def program_name;         File.basename($PROGRAM_NAME)                 end
    def usage_syntax_string; "#{program_name} [opts] {<yaccfile>|\"-\"}"   end
    def version_string;       VERSION                                      end


    def option_parser
      @op ||= OptionParser.new do |o|
        o.banner = usage
        o.on('--tt-grammar',
          '(development) Output the treetop grammar (grammar) to stdout'
        ){ @queue.push :run_treetop_grammar }
        o.on('-t<dir>', '--tempdir=<dir>',
          '(development) Read/write treetop grammar from/to tempdir'
        ){ |td| @queue.push :run_tempdir; @tempdir = td }
        o.on('-c', '--clear',
          '(development) rewrite grammars in tempdir (use with -t)'){
            @c[:clear_tempdir]=1 }
        o.on('-h', '--help', 'Shows this screen'){ @queue.push :run_help }
        o.on('-v', '--version', 'Display version information'
        ){ @queue.push :run_version }
      end
    end
    def agent
      @ag ||= Translator.new(@c)
    end
    def run_treetop_grammar
      @c.err.puts agent.yacc_treetop_grammar_text
      @exit_ok = true
    end
    def clear_tempdir
      require 'fileutils'
      [@treetop_path, @parser_path].each do |path|
        File.exist?(path) && FileUtils.rm(path, :verbose => true)
      end
    end
    def run_tempdir
      @treetop_path = File.join(@tempdir, 'yacc-to-treetop.treetop')
      @parser_path = File.join(@tempdir, 'yacc-to-treetop.rb')
      @c.has_key?(:clear_tempdir) and clear_tempdir
      File.exist?(@parser_path) ? @c.out.puts("Using #{@parser_path}") :
        write_yacc_treetop_parser
      @c[:treetop_parser_path] = @parser_path
    end
    def write_yacc_treetop_parser
      File.exist?(@treetop_path) or write_yacc_treetop_grammar_file
      "" != %x{which tt} or return fatal(
        "`tt` command not found! Is treetop gem installed and in PATH?")
      @c.err.puts(em('executing: ') + (cmd = "tt #{@treetop_path}"))
      require 'open3'
      out, err = Open3.popen3(cmd){ |_, sout, serr| [sout.read, serr.read] }
      if err.any?
        @c.out.puts color('error: ', :bold, :red) << "when compiling: #{cmd}:"
        @c.out.puts
        @c.out.puts err
        return fatal("#{program_name} exiting.")
      end
      out.any? and return fatal("unexpected output from tt: #{out.inspect}")
    end
    def write_yacc_treetop_grammar_file
      @c.err.write "Writing treetop file: #{@treetop_path}"
      File.directory?(File.dirname(@treetop_path)) or
        return fatal(
          "\nMust exist and be a directory: #{File.dirname(@treetop_path)}")
      num_bytes = nil
      File.open(@treetop_path, 'w+') do |fh|
        num_bytes = fh.write agent.yacc_treetop_grammar_text
      end
      @c.err.puts " (wrote #{num_bytes} bytes.)"
    end
    def run_translate
      @argv.size == 0 and @exit_ok and return
      @argv.size > 1 and return error("too many args. expecting 1 <yaccfile>")
      @argv.size == 0 and return error("missing <yaccfile> argument.")
      @argv.first == '-' and return
      File.exist?(@argv.first) or
        return error("<yaccfile> not found: #{@argv.first.inspect}")
      @c.in = File.open(@argv.first, 'r') # stream left open here!
      Translator.new(@c).run
    end
  end
  module Grammars; end

  module TreetopParserExtlib
    def my_failure_reason
      return nil unless (tf = terminal_failures) && tf.size > 0
      "Expected " +
        ( tf.size == 1 ?
          tf[0].expected_string.inspect :
          "one of #{tf.map{|f| f.expected_string.inspect}.uniq*', '}"
        ) + " at line #{failure_line}, column #{failure_column} " +
        "(byte #{failure_index+1}) #{my_input_excerpt}"
    end

    def num_context_lines; 4 end

    def my_input_excerpt
      0 == failure_index and return "at:\n1: #{input.match(/.*/)[0]}"
      all = input[index...failure_index].split("\n", -1)
      lines = all.slice(-1 * [all.size, num_context_lines].min, all.size)
      nos = failure_line.downto(
        [1, failure_line - num_context_lines + 1].max).to_a.reverse
      w = nos.last.to_s.size # width of greatest line number as string
      "after:\n" <<
        (nos.zip(lines).map{|no, s| ("%#{w}i" % no) + ": #{s}" } * "\n")
    end
  end

  class Translator
    class Fatal < ::RuntimeError; end
    @yttg = nil
    class << self
      def yacc_treetop_grammar_text
        @yttg ||= DATA.read
      end
    end
    def initialize ctx
      @c = ctx
    end
    def yacc_treetop_grammar_text
      self.class.yacc_treetop_grammar_text
    end
    def run
      begin
        _run
      rescue Fatal => e
        @c.in.close if @c.in && ! @c.in.closed?
        @c.err.puts(e.message) unless e.message == ""
      end
    end
  private
    def _run
      p = parser or return
      whole_file = @c.in.read
      @c.in.close
      resp = p.parse(whole_file)
      if resp.nil?
        rsn = p.failure_reason || "Got nil from parse without reason!"
        @c.err.puts rsn
      else
        sexp = resp.sexp
        PP.pp sexp
      end
    end
    def parse_stack_item str
      if md = /\A([^:]+):(\d+)(?::in `([^']+)')?\Z/.match(str)
        {:file => md[1], :line => md[2], :method => md[3] }
      end
    end
    def fatal msg=nil
      yield(@c) if block_given?
      msg.nil? or @c.err.puts(msg)
      h = parse_stack_item(caller[0]) and
        @c.err.puts '(from ' << [("#{h[:method]}" if h[:method]),
          ("line #{h[:line]}" if h[:line]) ].compact.join(' ') << ') '
      # this is subject to change but for now we just raise empty one
      raise Fatal.new("")
    end
    def parser
      instance_variable_defined?('@parser') and return @parser
      (klass = parser_class) ? (@parser = klass.new) : false
    end
    def parser_class
      self.class.const_defined?(:MyParser) and return MyParser
      cls = generated_parser_class or return false
      self.class.const_set(:MyParser, Class.new(cls))
      MyParser.class_eval do
        include TreetopParserExtlib
        alias_method :failure_reason, :my_failure_reason
      end
      MyParser
    end
    def generated_parser_class
      Grammars.const_defined?(:Yacc3wSpecParser) and
        return Grammars::Yacc3wSpecParser
      if @c.key?(:treetop_parser_path)
        load(@c[:treetop_parser_path]) # throws LoadError
        Grammars.const_defined?(:Yacc3wSpecParser) or return fatal do |c|
          c.err.puts "couldn't find Yacc3wSpecParser in "<<
            @c[:treetop_parser_path]
        end
      else
        r = ::Treetop.load_from_string(yacc_treetop_grammar_text)
        r.to_s =~ /Yacc3wSpecParser$/ or return fatal do |c|
          c.err.puts "expected Yacc3wSpecParser, had #{r}"
        end
      end
      Grammars::Yacc3wSpecParser
    end
  end
end

module Hipe::YaccToTreetop
  class SexpSelectorCompiler
    class << self
      def instance; @instance ||= new end
    end
    def initialize
      @selector_cache = Hash.new do |h,k|
        h[k] = nodes_selector_compile(k, true)
        h[k].freeze
      end
    end
    def compiled str
      @selector_cache[str]
    end
    def nodes_selector_compile str, freeze = false
      str.split(',', -1).map do |part|
        toks = node_selector_compile(part)
        freeze and toks.freeze
        toks
      end
    end
    def node_selector_compile str
      res = []
      s = StringScanner.new(str)
      begin
        if s.scan(/\*/); res.push '*'
        elsif s.scan(/\[/)
          d = s.scan(/\d+/) or fail("expecting digit had #{s.rest.inspect}")
          s.scan(/\]/) or fail("expecting ']' had #{s.rest.inspect}")
          res.push d.to_i
        else; fail("expecting '*' or '[' near #{s.rest.inspect}")
        end
      end until s.eos?
      res
    end
  end
  module ElementsSelector
    def elements_at str
      elements_at_recursive self, SexpSelectorCompiler.instance.compiled(str)
    end
    def elements_at_recursive node, parsed
      elements.nil? and return Array.new(parsed.size)
      parsed.map do |part|
        elements_at_part_recursive(node, part)
      end
    end
    def elements_at_part_recursive node, parsed
      cx = parsed.first == '*' ? node.elements : node.elements[parsed.first]
      cx.nil? and return nil
      if parsed.size > 1
        child_path = parsed[1..-1]
        cx = cx.map do |c|
          elements_at_part_recursive(c, child_path)
        end
      end
      cx
    end
  end
  class Sexpesque < Array
    alias_method :node_name, :first
    class << self
      def build name, *childs
        new([name, *childs])
      end
    end
  end
  module Standardy
    include ElementsSelector

    @modules = Hash.new do |h,k| h[k] =
      k.split('::').inject(Object){ |m,n| m.const_get n }
    end
    class << self
      attr_reader :modules
    end
    def build_sexp(name, *childs)
      (sexp_class || sexp_class_guess(name)).build(name, *childs)
    end
    def sexp
      standard_sexp
    end
    def standard_sexp
      if elements.nil?
        build_sexp(sexp_node_name, text_value)
      else
        build_sexp(sexp_node_name, * sexp_tail_recursive(self))
      end
    end
    def sexp_class
      nil # ovverride in the grammar or syntax node if necessary
    end
    def sexp_class_guess(name)
      mod = Standardy.modules[ self.singleton_class.ancestors[0].to_s.
        match(/\A(.+)::[^:]+::[^:]+\Z/)[1] ]
      cls = name.to_s.gsub(/([a-z])_([a-z])/){ "#{$1}#{$2.upcase}" }.
        sub(/^([a-z])/){ $1.upcase } << "Sexp"
      mod.const_defined?(cls) and return mod.const_get(cls)
      mod.const_defined?(:MySexp) and return mod.const_get(:MySexp)
      return Sexpesque
    end
    def sexp_node_name
      guess_node_name
    end
    def sexp_tail_recursive node
      sexps = []
      cx = node.respond_to?(:_) ? node.elements_at(_) : node.elements
      cx.each do |el|
        if el.respond_to?(:sexp)
          s = el.sexp
          s.nil? or sexps.push s # careful! this changes structure of things
        elsif el.elements.nil?
          sexps.push el.text_value
        else
          sexps.concat sexp_tail_recursive(el) # flatten it!
        end
      end
      if sexps.any? && sexps.index{|x| ! x.kind_of?(String)}.nil?
        sexps = [ sexps * '' ]
      end
      sexps
    end
    def guess_node_name
      m = singleton_class.ancestors.first.to_s.match(/([^:0-9]+)\d+$/)
      m[1].gsub(/([a-zA-Z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern if m
    end
    def singleton_class
      @sc ||= class << self; self end
    end
  end
  class Standard < ::Treetop::Runtime::SyntaxNode
    include Standardy
  end
end

module Hipe::YaccToTreetop
  module Grammars
    class MySexp < Sexpesque; end
    class FileSexp < MySexp
    end
    class CCommentSexp < MySexp
    end
  end
end



::Hipe::YaccToTreetop.cli.run(ARGV) if $PROGRAM_NAME == __FILE__

__END__
# The treetop grammar below is derived from parts of
#   http://dinosaur.compilertools.net/yacc/index.html
# and parts of a YACC-like grammar presented at
#   http://www.w3.org/TR/css3-selectors/
# It is not going to parse all YACC grammars, just those
# necessary for this project. (e.g. it only parses the 'rules'
# section, not the declarations or programs section.)

module Hipe
module YaccToTreetop
module Grammars
grammar Yacc3wSpec
  rule file
    space? (rool space?)+ space? <Standard> { }
  end
  rule space
    ( white / c_comment )+ <Standard> {
      def sexp
        case (sexp = standard_sexp).size
          when 1; nil
          when 2; sexp[1]
          else; sexp
        end
      end
    }
  end
  rule rool
    rule_name space? ':' space? rule_body space? ';' <Standard> {
      def sexp_node_name; :rule                  end
      def _;              '[0],[1],[3],[4],[5]'  end
    }
  end
  rule rule_name
    [a-zA-Z._] [a-zA-Z._0-9]* <Standard> { }
  end
  rule rule_body
    [^;]* <Standard> { }
  end
  rule c_comment
    '/*' ( !'*/' ( . / "\n" ) )* '*/' <Standard> { def _; '[1]' end }
  end
  rule white
    [ \t\n\r\f]+ <Standard> { def sexp; nil end }
  end
end
end
end
end
