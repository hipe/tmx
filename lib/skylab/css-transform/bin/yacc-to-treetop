#!/usr/bin/env ruby -w
require 'optparse'
require 'pp'
require 'strscan'
require 'rubygems'
require 'treetop'
# require 'ruby-debug'; $stderr.puts "\e[1;5;33mruby-debug\e[0m"

# ./bin/y2tt test/fixtures/yaccw3c/selectors.yaccw3c -g "Ho::Ha::Lol" > tmp.tt
# test case 2: ./bin/yacc-to-treetop test/fixtures/yaccw3c/050.sequences.y3
# test case 3: ./bin/yacc-to-treetop test/fixtures/yaccw3c/060.choice-parse.y3

module Hipe; end
module Hipe::YaccToTreetop
  VERSION = '0.0.0'
  class << self
    def cli; @cli ||= Cli.new end
    def autogenerated_text; @at ||= Templatiny.render(AUTOGENERATED, self) end
    def program_name; 'yacc-to-treetop' end # $PROGRAM_NAME won't work as api
  end

  class CliBase # experimental keep low level cli away from business logic
    def run argv
      @argv = argv
      @c = build_context
      @exit_ok = nil
      @queue = []
      begin
        option_parser.parse!(argv)
        @queue.push default_action
        catch(:early_exit){ @queue.each{ |meth| send meth } }
      rescue OptionParser::ParseError => e
        error e.message
      end
    end
  protected
    Codes = {:bold=>1,:dark_red=>31,:green=>32,:yellow=>33,:blue=>34,
      :purple=>35,:cyan=>36,:white=>37,:red=>38}
    def color(s, *a); "\e[#{a.map{|x|Codes[x]}.compact*';'}m#{s}\e[0m" end
    def em(s); style(s, :em) end
    Styles = { :error => [:bold, :red], :em => [:bold, :green] }
    def style(s, style); color(s, *Styles[style]) end
    def error msg
      @c.err.puts msg
      @c.err.puts usage
      @c.err.puts invite
    end
    def fatal msg
      @c.err.puts msg
      throw :early_exit
    end
    def invite
      em("#{program_name} -h") << " for help"
    end
    def run_help
      @c.err.puts option_parser.to_s
      @exit_ok = true
    end
    def run_version
      @c.err.puts "#{program_name} #{version_string}"
      @exit_ok = true
    end
    def usage
      "#{em('usage:')} #{usage_syntax_string}"
    end
  end

  class ExecutionContext < Hash
    def initialize
      @out = $stdout
      @err = $stderr
    end
    attr_accessor :in, :out, :err
    def builder
      @builder ||= TreetopBuilder.new(self)
    end
    def yacc_name_to_rule_name name
      name # @todo
    end
    def reverse_merge! *h
      h.each{ |h0| replace h0.merge(self) }
      self
    end
  end

  ExecutionContextDefaults = {
    :autogenerated_comment => true,
    :progressive           => true
  }

  class Cli < CliBase
    class << self
      def program_name;       File.basename($PROGRAM_NAME)                 end
    end
  private
    def build_context;        ExecutionContext.new                         end
    def default_action;       :run_translate                               end
    def program_name;         self.class.program_name                      end
    def usage_syntax_string; "#{program_name} [opts] {<yaccfile>|\"-\"}"   end
    def version_string;       VERSION                                      end


    def option_parser
      @op ||= OptionParser.new do |o|
        o.banner = usage
        o.on('-g=<grammar>', '--grammar=<grammar>',
        "Wrap output in grammar declaration (e.g. \"Mod1::Mod2::Grammar\")"
        ) { |g| @c[:grammar] = g }
        o.on('--tt-grammar',
          '(development) Output the treetop grammar (grammar) to stdout'
        ){ @queue.push :run_treetop_grammar }
        o.on('-t<dir>', '--tempdir=<dir>',
          '(development) Read/write yacc treetop grammar from/to tempdir'
        ){ |td| @queue.push :run_tempdir; @tempdir = td }
        o.on('-c', '--clear',
          '(development) rewrite grammars in tempdir (use with -t)'){
            @c[:clear_tempdir]=1 }
        o.on('-s', '--sexp',
          '(development) Dump sexp to stdout (twice to then exit)'){
            @c[@c.key?(:dump_sexp) ? :exit_after_dump : :dump_sexp] = true
        }
        o.on('-h', '--help', 'Shows this screen'){ @queue.push :run_help }
        o.on('-v', '--version', 'Display version information'
        ){ @queue.push :run_version }
      end
    end
    def agent
      @ag ||= Translator.new(@c)
    end
    def run_treetop_grammar
      @c.err.puts agent.yacc_treetop_grammar_text
      @exit_ok = true
    end
    def clear_tempdir
      require 'fileutils'
      [@treetop_path, @parser_path].each do |path|
        File.exist?(path) && FileUtils.rm(path, :verbose => true)
      end
    end
    def run_tempdir
      @treetop_path = File.join(@tempdir, 'yacc-to-treetop.treetop')
      @parser_path = File.join(@tempdir, 'yacc-to-treetop.rb')
      @c.has_key?(:clear_tempdir) and clear_tempdir
      File.exist?(@parser_path) ? @c.err.puts("Using #{@parser_path}") :
        write_yacc_treetop_parser
      @c[:treetop_parser_path] = @parser_path
    end
    def write_yacc_treetop_parser
      File.exist?(@treetop_path) or write_yacc_treetop_grammar_file
      "" != %x{which tt} or return fatal(
        "`tt` command not found! Is treetop gem installed and in PATH?")
      @c.err.puts(em('executing: ') + (cmd = "tt #{@treetop_path}"))
      require 'open3'
      out, err = Open3.popen3(cmd){ |_, sout, serr| [sout.read, serr.read] }
      if err.any?
        @c.out.puts style('error: ', :error) << "when compiling: #{cmd}:"
        @c.out.puts
        @c.out.puts err
        return fatal("#{program_name} exiting.")
      end
      out.any? and return fatal("unexpected output from tt: #{out.inspect}")
    end
    def write_yacc_treetop_grammar_file
      @c.err.write "Writing treetop file: #{@treetop_path}"
      File.directory?(File.dirname(@treetop_path)) or
        return fatal(
          "\nMust exist and be a directory: #{File.dirname(@treetop_path)}")
      num_bytes = nil
      File.open(@treetop_path, 'w+') do |fh|
        num_bytes = fh.write agent.yacc_treetop_grammar_text
      end
      @c.err.puts " (wrote #{num_bytes} bytes.)"
    end
    def run_translate
      @argv.size == 0 and @exit_ok and return
      @argv.size > 1 and return error("too many args. expecting 1 <yaccfile>")
      @argv.size == 0 and return error("missing <yaccfile> argument.")
      @argv.first == '-' and return
      File.exist?(@argv.first) or
        return error("<yaccfile> not found: #{@argv.first.inspect}")
      @c.in = File.open(@argv.first, 'r') # stream left open here!
      Translator.new(@c).run
    end
  end
  module Grammars; end

  module TreetopParserExtlib
    def my_failure_reason
      return nil unless (tf = terminal_failures) && tf.size > 0
      "Expected " +
        ( tf.size == 1 ?
          tf[0].expected_string.inspect :
          "one of #{tf.map{|f| f.expected_string.inspect}.uniq*', '}"
        ) + " at line #{failure_line}, column #{failure_column} " +
        "(byte #{failure_index+1}) #{my_input_excerpt}"
    end

    def num_context_lines; 4 end

    def my_input_excerpt
      0 == failure_index and return "at:\n1: #{input.match(/.*/)[0]}"
      all = input[index...failure_index].split("\n", -1)
      lines = all.slice(-1 * [all.size, num_context_lines].min, all.size)
      nos = failure_line.downto(
        [1, failure_line - num_context_lines + 1].max).to_a.reverse
      w = nos.last.to_s.size # width of greatest line number as string
      "after:\n" <<
        (nos.zip(lines).map{|no, s| ("%#{w}i" % no) + ": #{s}" } * "\n")
    end
  end

  class Translator
    class Fatal < ::RuntimeError; end
    @yttg = nil
    class << self
      def yacc_treetop_grammar_text
        GrammarText
      end
    end
    def initialize ctx=nil
      @c = if ctx.nil?
        ExecutionContext.new($stdin, $stdout, $stderr).
          reverse_merge!(ExecutionContextDefaults)
      elsif ctx.kind_of?(ExecutionContext)
        ctx
      elsif ctx.kind_of?(Hash)
        ec = ExecutionContext.new.reverse_merge!(ctx,
          ExecutionContextDefaults)
        [:in, :out, :err].each do |m|
          ctx.respond_to?(m) and ec.send("#{m}=", ctx.send(m))
        end
        ec
      else
        ctx # whatever no never dumb
      end
    end
    def execution_context; @c end
    def yacc_treetop_grammar_text
      self.class.yacc_treetop_grammar_text
    end
    def run
      begin
        _run
      rescue Fatal => e
        @c.err.puts(e.message) unless e.message == ""
      ensure
        @c.in.close if @c.in && ! @c.in.closed?
      end
    end
    TranslateDefaults = {:verbose => true, :force => false}
    def translate from_path, to_path, opts = {}
      o = merge_opts(opts, @c, TranslateDefaults)
      if File.exist?(to_path)
        unless o[:force]
          @c.err.puts "exists: #{shortpath(to_path)}. skipping"
          return :exists
        end
        s = nil; File.open(to_path) { |fh| s = fh.gets }
        (s.nil? or s == Hipe::YaccToTreetop.autogenerated_text) or
          raise Fatal.new("#{s.inspect} must be "<<
            " #{Hipe::YaccToTreetop.autogenerated_text.inspect}")
        verb = "regenerating"
      else
        verb = "generating"
      end
      o[:verbose] and @c.err.puts "#{verb}: #{shortpath(to_path)} " <<
        " from #{shortpath(from_path)}."
      begin
        @c.in = File.open(from_path, 'r')
        @c.out = File.open(to_path, 'w')
        _run
      ensure
        @c.in.closed? or @c.in.close
        @c.out.closed? or @c.out.close
      end
      true
    end
  private
    def _run
      p = parser or return
      whole_file = @c.in.read
      @c.in.close
      resp = p.parse(whole_file)
      if resp.nil?
        rsn = p.failure_reason || "Got nil from parse without reason!"
        @c.err.puts rsn
      else
        sexp = resp.sexp
        @c.key?(:dump_sexp) and PP.pp(sexp, @c.out)
        @c.key?(:exit_after_dump) and return
        @c.key?(:progressive) and @c.builder.progressive_output!
        sexp.translate(@c)
        @c.key?(:progressive) or @c.out.write(@c.builder.ruby)
      end
    end
    def extend_ec *chain
      cx = chain.shift
      while chain.any? ; cx.merge(!chain.shift) ; end
      cx
    end
    def parse_stack_item str
      if md = /\A([^:]+):(\d+)(?::in `([^']+)')?\Z/.match(str)
        {:file => md[1], :line => md[2], :method => md[3] }
      end
    end
    def fatal msg=nil
      yield(@c) if block_given?
      msg.nil? or @c.err.puts(msg)
      h = parse_stack_item(caller[0]) and
        @c.err.puts '(from ' << [("#{h[:method]}" if h[:method]),
          ("line #{h[:line]}" if h[:line]) ].compact.join(' ') << ') '
      # this is subject to change but for now we just raise empty one
      raise Fatal.new("")
    end
    # given an array of hashes
    # @return a new hash with only the keys of the last hash and the values
    # of the first hash found with that key
    def merge_opts *ox
      defaults = ox.last
      Hash[ defaults.keys.map do |k|
        [ k, ox.detect{ |h| h.key?(k) }[k] ]
      end ]
    end
    def parser
      instance_variable_defined?('@parser') and return @parser
      (klass = parser_class) ? (@parser = klass.new) : false
    end
    def parser_class
      self.class.const_defined?(:MyParser) and return MyParser
      cls = generated_parser_class or return false
      self.class.const_set(:MyParser, Class.new(cls))
      MyParser.class_eval do
        include TreetopParserExtlib
        alias_method :failure_reason, :my_failure_reason
      end
      MyParser
    end
    def shortpath path
      @c.key?(:root) or return path
      @rootre ||= %r{\A#{Regexp.escape(@c[:root])}/?}
      path.sub(@rootre, '')
    end
    def generated_parser_class
      Grammars.const_defined?(:Yacc3wSpecParser) and
        return Grammars::Yacc3wSpecParser
      if @c.key?(:treetop_parser_path)
        load(@c[:treetop_parser_path]) # throws LoadError
        Grammars.const_defined?(:Yacc3wSpecParser) or return fatal do |c|
          c.err.puts "couldn't find Yacc3wSpecParser in "<<
            @c[:treetop_parser_path]
        end
      else
        r = ::Treetop.load_from_string(yacc_treetop_grammar_text)
        r.to_s =~ /Yacc3wSpecParser$/ or return fatal do |c|
          c.err.puts "expected Yacc3wSpecParser, had #{r}"
        end
      end
      Grammars::Yacc3wSpecParser
    end
  end
end

module Hipe::YaccToTreetop
  class SexpSelectorCompiler
    class << self
      def instance; @instance ||= new end
    end
    def initialize
      @selector_cache = Hash.new do |h,k|
        h[k] = nodes_selector_compile(k, true)
        h[k].freeze
      end
    end
    def compiled str
      @selector_cache[str]
    end
    def nodes_selector_compile str, freeze = false
      str.split(',', -1).map do |part|
        toks = node_selector_compile(part)
        freeze and toks.freeze
        toks
      end
    end
    def node_selector_compile str
      res = []
      s = StringScanner.new(str)
      begin
        if s.scan(/\*/); res.push '*'
        elsif s.scan(/\[/)
          d = s.scan(/\d+/) or fail("expecting digit had #{s.rest.inspect}")
          s.scan(/\]/) or fail("expecting ']' had #{s.rest.inspect}")
          res.push d.to_i
        else; fail("expecting '*' or '[' near #{s.rest.inspect}")
        end
      end until s.eos?
      res
    end
  end
  module ElementsSelector
    def elements_at str
      elements_at_recursive self, SexpSelectorCompiler.instance.compiled(str)
    end
    def elements_at_recursive node, parsed
      elements.nil? and return Array.new(parsed.size)
      parsed.map do |part|
        elements_at_part_recursive(node, part)
      end
    end
    def elements_at_part_recursive node, parsed
      mix = parsed.first == '*' ? node.elements : node.elements[parsed.first]
      mix.nil? and return nil
      parsed.size == 1 and return mix
      child_path = parsed[1..-1]
      if parsed.first == '*'
        mix.map do |ch|
          ch.elements.nil? ? nil : elements_at_part_recursive(ch, child_path)
        end
      else
        mix.elements.nil? ? nil : elements_at_part_recursive(mix, child_path)
      end
    end
  end
  class Sexpesque < Array
    alias_method :node_name, :first
    class << self
      def build name, *childs
        new([name, *childs])
      end
    end
    # begin sexp scanner methods
    def each_before name, &block
      b = if block_given?; block else
        arr = []; lambda{ |x| arr.push(x) }
      end
      c = (@current ||= 1); found = nil
      c.upto(size-1){ |i| self[i].first==name and found=i and break }
      found.nil? and fail("no where in sexp: #{name.inspect}")
      until(name == self[@current].first || @current >= size)
        b.call self[@current]
        @current += 1
      end
      arr unless block_given?
    end
    def with name
      fail("not current: #{name.inspect}") unless self[@current].first == name
      ret = block_given? ? yield(self[@current]) : self[@current]
      @current += 1
      ret
    end
    def until_end &block
      b = if block_given?; block else
        arr = []; lambda{ |x| arr.push(x) }
      end
      until @current >= size; b.call(self[@current]); @current += 1; end
      arr unless block_given?
    end
    # end sexp scanner methods
  end
  module Standardy
    include ElementsSelector

    @modules = Hash.new do |h,k| h[k] =
      k.split('::').inject(Object){ |m,n| m.const_get n }
    end
    class << self
      attr_reader :modules
    end
    def build_sexp(name, *childs)
      (sexp_class || sexp_class_guess(name)).build(name, *childs)
    end
    def sexp
      standard_sexp
    end
    def standard_sexp
      if elements.nil?
        build_sexp(sexp_node_name, text_value)
      else
        build_sexp(sexp_node_name, * sexp_tail_recursive(self))
      end
    end
    def sexp_class
      nil # ovverride in the grammar or syntax node if necessary
    end
    def sexp_class_guess(name)
      mod = Standardy.modules[ self.singleton_class.ancestors[0].to_s.
        match(/\A(.+)::[^:]+::[^:]+\Z/)[1] ]
      cls = name.to_s.gsub(/([a-z])_([a-z])/){ "#{$1}#{$2.upcase}" }.
        sub(/^([a-z])/){ $1.upcase } << "Sexp"
      mod.const_defined?(cls) and return mod.const_get(cls)
      mod.const_defined?(:MySexp) and return mod.const_get(:MySexp)
      return Sexpesque
    end
    def sexp_node_name
      guess_node_name
    end
    def sexp_tail_recursive node
      sexps = []
      cx = node.respond_to?(:sexp_selector) ?
        node.elements_at(node.sexp_selector) : node.elements
      cx.each do |el|
        if el.nil?
          # always ignored, changes structure
        elsif el.respond_to?(:sexp)
          s = el.sexp
          s.nil? or sexps.push s # careful! this changes structure of things
        elsif el.elements.nil?
          t = el.text_value
          t == "" or sexps.push t # ditto here, changes structure
        else
          sexps.concat sexp_tail_recursive(el) # flatten it!
        end
      end
      if sexps.any? && sexps.index{|x| ! x.kind_of?(String)}.nil?
        sexps = [ sexps * '' ]
      end
      sexps
    end
    def guess_node_name
      m = singleton_class.ancestors.first.to_s.match(/([^:]*[^:0-9])\d+$/)
      m[1].gsub(/([a-zA-Z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern if m
    end
  # alternate version below, does last not first. keep it lying around for now
  # extreme haxie: find the last ancestor that has the same containing
  # module as the first.  deduce rule used by using this module name.
  # def guess_node_name
  #   m = singleton_class.ancestors.first.to_s.match(/(\A.+[^:])::[^:]+\z/) or
  #     return nil
  #   idx = singleton_class.ancestors.index{ |x| 0 != x.to_s.index(m[1]) }
  #   m = singleton_class.ancestors[idx-1].to_s.match(/([^:]*[^:0-9])\d+$/)
  #   m[1].gsub(/([a-zA-Z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern if m
  # end
    def singleton_class
      @sc ||= class << self; self end
    end
  end
  class Standard < ::Treetop::Runtime::SyntaxNode
    include Standardy
  end
end

## here is the abstractable code for generating treetop grammars
# (adapted from predecessor)
module Hipe::YaccToTreetop

  class TreetopBuilder < ::Treetop::Compiler::RubyBuilder
    class ProgressiveOutputAdapter
      def initialize out; @out = out end
      def <<(*a); @out.write(*a); self end
    end
    def initialize ctx
      super()
      @ctx = ctx
    end
    def progressive_output!
      @ruby = ProgressiveOutputAdapter.new(@ctx.out)
    end
    def rule_declaration name, &block
      self << "rule #{name}"
      indented(&block)
      self << "end"
    end
    def grammar_declaration(name, &block)
      self << "grammar #{name}"
      indented(&block)
      self << "end"
    end
    def write *a
      @ruby.<<(*a)
    end
  end
  MyInspectKey = ::PP::PPMethods::InspectKey
  class PpRhs < ::PP
    def initialize(*a)
      @ctx = a.pop
      super(*a)
    end
    attr_accessor :ctx
    alias_method :execution_context, :ctx
    def pp_rhs node
      id = node.__id__
      if Thread.current[MyInspectKey].include? id
        group { node.pretty_print_cycle self } # just to be safe!
        return
      end
      begin
        Thread.current[MyInspectKey] << id
        @ctx[:in_the_future] and ctx.delete(:in_the_future).call(node)
        group { node.pretty_print_rhs self }
        @ctx[:prev_node_name] = node.respond_to?(:first) ?
          node.first : node.class
      ensure
        Thread.current[MyInspectKey].pop unless PP.sharing_detection
      end
    end
    def break
      flush
      @output << @newline
      @output << @genspace.call(@indent)
      @output_width = @indent
      @buffer_width = 0
    end
  end
  class Templatiny # a tiny fraction of ERB in one screen of code
    class << self
      alias_method :go, :new
      protected :new
      def render str, datasrc
        require 'stringio'
        out = StringIO.new
        new(str).write(out, datasrc)
        out.rewind
        out.read
      end
    end
  public
    def write out, datasource
      @out = out;  @datasource = datasource
      parsed.each { |meth, *a| send(meth, *a) }
    end
  protected
    def initialize str
      @str = str
    end
    def parsed
      instance_variable_defined?('@parsed') and return @parsed
      @parsed = []
      pos = 0
      scn = StringScanner.new(@str)
      until scn.eos?
        if (! size_skipped = scn.skip_until(/<%= */))
          @parsed.push [:string, scn.rest]
          break
        else
          raw = scn.string.slice(pos, size_skipped - scn.matched.size)
          raw != "" and @parsed.push [:string, raw]
          name = scn.scan(/[_a-z]+/) or fail("bad varname: #{scn.rest}")
          scn.skip_until(/ *%>/) or fail("\"%>\" not found: #{scn.rest}")
          pos = scn.pos
          @parsed.push [:write_variable, name.intern]
        end
      end
      @parsed
    end
    def write_variable name
      @out.write @datasource.send(name)
    end
    def string s
      @out.write s
    end
  end
end
## end abstractable


module Hipe::YaccToTreetop
  AUTOGENERATED =
    "# Autogenerated from <%= program_name %>. Edits may be lost.\n"

  module Grammars
    class MySexp < Sexpesque
      def translate c
        require 'stringio'
        s = StringIO.new
        PP.pp(self, s)
        s.rewind
        c.builder << "Help, fixme: #{s.read}"
      end
      # debugging and development only!! @todo
      def pretty_print_rhs q
        q.group(1, 'pprhs![', ']') {
          q.seplist(self) { |v|
            if v.respond_to?(:pretty_print_rhs)
              q.pp_rhs(v)
            else
              q.pp(v) # usually symbols & strings
            end
          }
        }
      end
    end
    class SpecSexp < MySexp
      def translate c
        @ctx = c
        @nest = [ lambda{ go_rules } ]
        @ctx.key?(:grammar) and go_grammar
        @ctx[:autogenerated_comment] and go_autogenerated_comment
        @nest.pop.call
      end
      def go_autogenerated_comment
        @ctx.out.puts ::Hipe::YaccToTreetop.autogenerated_text
      end
      def go_grammar
        parts = @ctx[:grammar].split('::')
        gname = parts.pop
        @nest.push lambda{@ctx.builder.grammar_declaration(gname, &@nest.pop)}
        while mod = parts.pop
          @nest.push lambda{ |mymod| lambda {
            @ctx.builder.module_declaration(mymod, &@nest.pop)
          } }.call(mod)
        end
      end
      def go_rules
        self[1..-1].each{ |sexp| sexp.translate(@ctx) }
      end
    end
    class SpaceSexp < MySexp
      def translate c
        self[1..-1].each { |ch| ch.translate(c) }
      end
      def pretty_print_rhs q
        self[1..-1].each { |ch| q.pp_rhs(ch) }
      end
    end
    class CCommentSexp < MySexp
      def translate c
        c.builder << (s = unindented_ruby_comment_block)
        s.index("\n") and c.builder.newline
      end
      def pretty_print_rhs q
        q.text(s = unindented_ruby_comment_block)
        q.break
        if s.index("\n")
          q.break
        elsif q.ctx[:prev_node_name] == :c_comment
          q.execution_context[:in_the_future] = lambda do |node|
            if node.first != :c_comment
              q.break
            end
          end
        end
      end
    private
      def unindented_ruby_comment_block
        "# #{self[1].strip.gsub("\n", "\n# ")}"
      end
    end
    class RuleSexp < MySexp
      def translate c
        each_before(:rule_name){ |ch| ch.translate(c) }
        b = c.builder
        use_name = with(:rule_name){ |ch| c.yacc_name_to_rule_name(ch[1]) }
        b.rule_declaration(use_name) do
          q = PpRhs.new(c.out, c[:width] || 79, c)
          q.guard_inspect_key do # very very unlikely to be necessary but meh
            b.write "".indent(b.level)
            q.nest(b.level) do
              until_end { |ch| q.pp_rhs(ch) }
            end
          end
          q.flush
          b.newline
        end
      end
    end
    class SequenceSexp < MySexp
      def pretty_print_rhs q
        q.group(1) {
          # q.seplist(self[1..-1], lambda{ q.breakable(' ') }) { |v|
          #   q.pp_rhs v
          # }
          first = true
          self[1..-1].each do |v|
            q.breakable(' ') unless (first || v.first == :w3c_range)
            first = false
            q.pp_rhs(v)
          end
        }
      end
    end
    class ChoiceSexp < MySexp
      def pretty_print_rhs q
        q.group(1) do
          first = true
          self[1..-1].each do |v|
            if first
              q.pp_rhs(v)
              first = false
            elsif v.first == :w3c_range
              q.pp_rhs(v)
            else
              q.text ' / '
              q.pp_rhs(v)
            end
          end
        end
      end
    end
    class RuleNameSexp < MySexp
      def pretty_print_rhs q
        q.text q.execution_context.yacc_name_to_rule_name(self[1])
      end
    end
    class LiteralSexp < MySexp # @todo test '\123' etc!!
      def pretty_print_rhs q
        # for now output them quiet literally but in doubles not singles
        q.text "\"#{self[1]}\""
      end
    end
    class W3cRangeSexp < MySexp
      def pretty_print_rhs q
        q.text self[1]
      end
    end
    class W3cGroupingSexp < MySexp
      def pretty_print_rhs q
        q.group(0, '( ', ' )') {
          q.seplist(self[1..-1], lambda{ q.breakable(' ') }) { |v|
            q.pp_rhs v
          }
        }
      end
    end
  end
end

::Hipe::YaccToTreetop::GrammarText = <<-'TREETOP_GRAMMAR'
# The treetop grammar below is derived from parts of
#   http://dinosaur.compilertools.net/yacc/index.html
# and parts of a YACC-like grammar presented at
#   http://www.w3.org/TR/css3-selectors/
# It is not going to parse all YACC grammars, just those
# necessary for this project. (e.g. it only parses the 'rules'
# section, not the declarations or programs section.)

module Hipe
module YaccToTreetop
module Grammars
grammar Yacc3wSpec
  rule spec
    space? (rool space?)+ space? <Standard> { }
  end
  rule space
    ( white / c_comment )+ <Standard> {
      def sexp
        case (sexp = standard_sexp).size
          when 1; nil
          when 2; sexp[1] == '' ? nil : sexp[1]
          else; sexp
        end
      end
    }
  end
  rule rool
    rule_name space? ':' space? pattern space? ';' <Standard> {
      def sexp_node_name; :rule                  end
      def sexp_selector;  '[0],[1],[3],[4],[5]'  end
    }
  end
  rule rule_name
    [a-zA-Z._] [a-zA-Z._0-9]* <Standard> { }
  end
  rule pattern
    choice / sequence / space? <Standardy> { }
  end
  rule choice
    choice_part space? pipe space? choice_part ( space? pipe space? choice_part )*
    <Standard> { }
  end
  rule pipe
    '|' <Standard> { def sexp; end }
  end
  rule choice_part
    sequence / space+
  end
  rule sequence
    pattern_part ( space+ pattern_part )* <Standard> { }
  end
  rule pattern_part
    ( rule_name / literal / w3c_grouping ) w3c_range?
  end
  rule literal
    "'" ( '\\' ( [nr'\\tbf] / [0-9] 3..3 ) / [^'] ) "'" <Standard> {
      def sexp_selector;    '[1]'             end
    }
  end
  rule w3c_range
    ( '*' / '+' / '?' ) <Standardy> { }
  end
  rule w3c_grouping
    '[' space? pattern space? ']' <Standard> {
      def sexp_selector;     '[1],[2],[3]'     end
    }
  end
  rule c_comment
    '/*' ( !'*/' ( . / "\n" ) )* '*/' <Standard> {
      def sexp_selector;  '[1]'                   end
    }
  end
  rule white
    [ \t\n\r\f]+ <Standard> { def sexp; nil end }
  end
end
end
end
end
TREETOP_GRAMMAR

::Hipe::YaccToTreetop.cli.run(ARGV) if $PROGRAM_NAME == __FILE__
