require_relative 'api/test-support'

module Skylab::Flex2Treetop::MyTestSupport

  describe "[f2tt] API" do

    extend API::ModuleMethods ; include API::InstanceMethods  # #posterity

    context "basics" do

      it "loads" do
        F2TT_::API
      end

      it "ping - everybody gets an errstream" do
        _API_invoke :ping, :arg_1, :_x_
        expect 'helo:(_x_)'
        expect_no_more_lines
        @result.should eql :_hello_from_API_
      end
    end

    context "action extent mechanics" do

      it "request a nonexistent action - X (name error)" do
        -> do
          _API_invoke :wiggle, :you_never, :see_these, :args
        end.should raise_error ::NameError, /\bcannot \"wiggle\"/
      end
    end

    context "basic business and parameters" do

      it "request the 'version' action - result is a version string" do
        x = _API_invoke :version
        x.should match %r(\A#{ ::Regexp.escape API::PROGNAME }: #{
          }\d+(?:\.\d+)*\z)
      end

      it "request the 'version' action and pass a flag" do
        x = _API_invoke :version, :bare
        x.should match %r(\A\d+(?:\.\d+)*\z)
      end
    end

    context "core business" do

      it "infile not exist" do
        _API_invoke :translate,
          * emitters,
          :flexfile, tmpdir.join( 'not-there.flex' ).to_path,
          * outpath( '_no_see_' )

        expect %r(\bNo such 'flexfile' - «[^»]+not-there\.flex»\z)
        expect_no_more_lines
        @result.should eql :not_found
      end

      it "infile not file" do
        td_ = tmpdir.clear.touch_r 'some-dir/'
        _API_invoke :translate,
          * emitters,
          * outpath( '_meh_' ),
          :flexfile, td_.to_path
        expect %r(\A«[^»]+some-dir/» exists but is not a file, it is a directory\b)
        @result.should eql :not_file
      end

      it "infile exist, outfile exist and force not present" do
        _out_pn = tmpdir.clear.write 'outie.rb', 'some content'
        _API_invoke :translate,
          :flexfile, mini,
          * emitters,
          * outpath( _out_pn )
        expect %r(\A'path' exists, won't overwrite without 'force': .+\boutie\b)
        @result.should eql :exists
      end

      it "infile exist, outfile not file" do
        _in_pn = tmpdir.clear.write 'innie', 'xx'
        _out_pn = tmpdir.touch_r 'some-dir/'
        _API_invoke :translate,
          :flexfile, _in_pn.to_path,
          * emitters,
          * outpath( _out_pn ),
          :force
        expect %r(\AIs a directory -.+\bsome-dir\b)
        @result.should eql :not_file
      end
    end

    context "verify treetop output - normal case" do

      it "o" do
        tmpdir.prepare
        outfile = tmpdir.join 'oter.rb'
        _API_invoke :translate,
          :flexfile, mini,
          * outpath( outfile ),
          * emitters
        expect_info_lines
        @ln_source.change_upstream_stream_to_open_filehandle outfile.open 'r'
        verify_first_few_lines_of_mini_flex
        verify_last_few_lines_of_mini_flex
        @result.should eql :translated
      end

      def expect_info_lines
        expect %r(\bcreating .*\boter\.rb with .*\bmini\.flex\b)i
        expect %r(\bCan't deduce a treetop rule name from: #{
          }"return \*yytext;" Skipping\.\z)i
        expect_no_more_lines
      end

      def verify_first_few_lines_of_mini_flex
        expect %r(\A# Autogenerated by flex2tree)
        _line = gets_some_first_chopped_line_that_does_not_match %r(\A(?:#|$))
        _line.should eql "rule escape"
      end

      def verify_last_few_lines_of_mini_flex
        exp_a = <<-'HERE'.unindent.split %r((?<=\n))
          rule _ignore_comments_
            "\/" "\*" [^*]* "\*"+ ([^/*] [^*]* "\*"+)* "\/"
          end
        HERE
        skip_until_last_N_lines exp_a.length
        while (( line = exp_a.shift ))
          expect line.chop!
        end ; nil
      end
    end

    context "verify treetop output - wrap in grammar name mono" do

      _NUM_BODY_LINES = 14

      it "o" do
        o = tmpdir.clear.join 'outie.rb'
        _API_invoke :translate,
          :wrap_in_grammar_s, "Danbury",
          * outpath( o ),
          * emitters,
          :flexfile, mini
        skip_all_contiguous_emissions_on_channel :stderr
        @ln_source.change_upstream_stream_to_open_filehandle o.open 'r'
        skip_any_comment_lines
        expect 'grammar Danbury'
        count = skip_contiguous_chopped_lines_that_match(
          /\A[ ]{2,}[^[:space:]]/ )
        ( _NUM_BODY_LINES .. _NUM_BODY_LINES ).should be_include count
        expect 'end'
        expect_no_more_lines
        @result.should eql :translated
      end
    end

    context "verify treetop output - wrap in grammar name poly" do

      it "o" do
        o = tmpdir.clear.join 'outie.rb'
        _API_invoke :translate,
          :wrap_in_grammar_s, "Fibble::Toppel",
          * outpath( o ),
          :flexfile, mini,
          * emitters
        @result.should eql :translated
        fh = o.open 'r'
        init_line_source_as build_line_source_from_open_file_IO fh
        skip_any_comment_lines
        expect 'module Fibble'
        expect '  grammar Toppel'
        expect '    # from flex name definitions'
        fh.close
      end
    end

    context "wrap in bad grammar name" do

      it "(note it still begins the file :/) x" do
        o = tmpdir.clear.join 'never-make-this.rb'
        _API_invoke :translate,
          :wrap_in_grammar_s, 'Doonesbury Cartoon',
          * emitters,
          :flexfile, mini,
          * outpath( o )
        expect %r(\Acreating [^ ]+never-make-this)  # too bad
        expect "grammar namespaces look like \"Foo::BarBaz\". #{
          }this is not a valid grammar namespace: \"Doonesbury Cartoon\""
        expect_no_more_lines
        io = o.open 'r'
        @ln_source.change_upstream_stream_to_open_filehandle io
        expect %r(\A# Autogenerated)
        io.close
        @result.should eql :translate_failure
      end
    end

    context "option - show sexp" do

      it "o" do
        o = tmpdir.clear.join 'no-really-never-make-this.rb'
        _API_invoke :translate,
          :show_sexp_only,
          * emitters,
          * outpath( o ),
          :flexfile, mini
        expect '[:file,'
        count = skip_until_last_N_lines 1
        count.should eql 59
        expect %r(\A {2,} :action=>\[:action, "return \*yytext;)
        expect_no_more_lines
        @result.should eql :showed_sexp
      end
    end

    context "options - read parser from filesystem" do

      it "nosaj thing - x" do
        foo = tmpdir.clear.join 'not-a-dir'
        _API_invoke_with_parser_dir foo
        expect %r(\ANo such file or directory #{ XX }- [^ ]+/not-a-dir\z)
        expect_no_more_lines
        @result.should eql :parser_dir_not_exist
      end

      it "saj thing - o", alone: true do
        foo = tmpdir.clear.touch_r 'a-dir/'
        _API_invoke_with_parser_dir foo
        expect %r(\Awrote [^ ]+/a-dir/flex-to-treetop\.treetop #{
          }.+ writing [^ ]+/a-dir/flex-to-treetop\.rb\.\z)
        expect %r(\A\(treetop wrote \d{5} bytes\)\z)
        peek = line_source.peek_any_chopped_line
        if 'touched ' == peek[ 0, 8 ]
          expect_loaded_from_filesystem_successfully
        else
          expect_the_thing_about_how_the_constant_is_already_loaded
        end
      end

      def expect_loaded_from_filesystem_successfully
        debug_IO.puts "  (#{ _EM "THE FOLLOWING TEST" } is happy it ran alone.)"
        expect 'touched files. nothing more to do.'
        expect_no_more_lines
        @result.should eql :filesystem_touched
      end

      def expect_the_thing_about_how_the_constant_is_already_loaded
        debug_IO.puts "  (run #{ _EM "THE FOLLOWING TEST" } '-t alone' too!)"
        expect %r(\Acannot use FS parser, a parser class is already loaded)
        expect_no_more_lines
        @result.should eql :cannot_use_FS_flex_file_parser_already_loaded
      end

      def _API_invoke_with_parser_dir foo
        _API_invoke :translate,
          :use_FS_parser, :FS_parser_dir, foo, :endpoint_is_FS_parser,
          :flexfile, mini,
          * emitters,
          * outpath( 's' )
      end

      def expect_beginning_cruft
        expect %r(\boverwriting empty file: s\b)
      end
    end
  end
end
