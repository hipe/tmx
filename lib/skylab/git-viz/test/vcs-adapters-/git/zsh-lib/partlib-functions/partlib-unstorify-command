#!/usr/bin/env zsh

typeset cmd="$1"
typeset odir="${asset_output_dir:-$2}"

-bork () {
  -serr $*
  return general_error
}

-serr () {
  print -- $* 1>&2
}

typeset general_error=3 general_success=0

if [[ -z $cmd || -z $odir ]] ; then
  -bork "usage: $0 <storified git command> [<asset directory>]" || return $?
fi

if [[ ! -d $odir ]] ; then
  -bork "not a directory: $odir" || return $?
fi

typeset logfile=$odir/log

if [[ ! -s $logfile ]] ; then
  -bork "not there or empty - $logfile" || return $?
fi

setopt extendedglob
typeset match mbegin mend

typeset cmd_head cmd_fake_sha cmd_tail
typeset cmd_real_sha

-partlib-unstorify-command () {
  -match-fake-command || return $?
  -grep-logfile || return $?
  print "${cmd_head}${cmd_real_sha}${cmd_tail}"
  return $general_success
}

-match-fake-command () {
  if [[ $cmd = (#b)(*\ )([a-z0-9]##)(\ --) ]] ; then
    cmd_head=$match[1] ; cmd_fake_sha=$match[2] ; cmd_tail=$match[3]
  else
   -bork "failed to match against our pattern the fake cmd: $cmd"
  fi
}

-grep-logfile () {
  typeset -a others; others=()
  typeset found line
  while read -r line ; do
    if [[ $line = (#b)\[master\ ([a-f0-9]##)\]\
\ commit\ to\ be\ treated\ as\ commit\ ([a-f0-9]##) ]]
    then
      if [[ $match[2] == $cmd_fake_sha ]] ; then
        found=$match[1]
        break
      else
        others[$(($#others+1))]=$match[2]
      fi
    fi
  done < $logfile
  if [[ -z $found ]] ; then
    -bork "fake SHA not found \"$cmd_fake_sha\". known: (${(f)others})"
  else
    cmd_real_sha=$found
  fi
}

-partlib-unstorify-command
