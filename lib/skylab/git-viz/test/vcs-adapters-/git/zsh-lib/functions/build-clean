#!/usr/bin/env zsh  #just-for-syntax-highlighting

-print-component-node-description () {
  serr
  serr "$( -hdr "description:" ) remove many things"
}
-say-component-node-args () {
  typeset s="$( -component-node-first-arg-moniker )"
  print "clean $s [..]"
}
-say-component-node-child-moniker () {
  print "asset"
}
-say-component-node-function-name-prefix-infix () {
  print -- '-asset-'
}
-say-build-script-for-child-node () {
  print -- $component_node_local_top_dir/asset-script/for-mock-$1/script/build
}

typeset -a rest ; rest=("${*[@]}")

# this script can be invoked with the syntax of 'all' (namely, with no
# other arguments) or it can cherry-pick particular **assets** (not parts)
# to remove. hence the below two logic branches look like the corresponding
# sections in the sibling scripts for 'part' and all variously

if [[ 'git' == $rest[1] ]] ; then
  rest[1,1]=()  # we don't need 'git' in there any more,
  rest[2,1]=(clean)  # but we need to slip the adverb in after the asset
  # so now it is <asset> <adverb> [user args]
  component-node-splay
else
  dispatch-target-and-args-to-all clean "${rest[@]}"
fi
