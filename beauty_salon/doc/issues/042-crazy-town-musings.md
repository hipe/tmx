# crazy-town musings :[#042]

## "corpus mode" :[#here.B]

### background

our efforts at developing a parsing and processing infrastructure
have thus far been (and continue to be) “pragmatic” and “black box”.
what we mean by this:

  - “pragmatic”: for now, we only need this to work on our own code,
    not all ruby code in the universe.

  - “black box”: for fun (such as it is), we are doing this from
    the outside in, taking AST’s as generated by our code and trying
    to infer there formal structure from their instances, rather than
    using any available documentation or source code as a reference
    for this. (perhaps to be super-duper robust we will invert this
    at the end, and look for holes by consulting the source grammar
    of the remote library (because i don’t think it’s documented
    per se)).

at this moment (:#history-A.1) in the entire “ecosystem” there are 1521
“asset” files. we both define “asset files” and find them by:

    find . -type f -name '*.rb' \( -not -name '*_spec.rb' \)

we use this set of files at a litmus test to signal when our parsing
facilities are adequately robust for our own purposes. this set of
files (and more generally datasets like it) is known as a “corpus”.

(eventually and soon we will augment our work by using the set of all
*test* files as a corpus.)

this is the way our “black box” approach plays out: one-by-one, we
run each of our 1500+ asset files against our system. as each next
hole is found (which raises an exception), we develop/refactor our
system and try to pick up where we left off, ideally (eventually)
reaching the last file and passing our litmus test (once we have
confirmed that we didn’t regress).



### design objective

once we reached the completion of one sidesystem (of 33), a couple
related painpoints became evident:

  - zeroing-in on the file of interest became an easy-but-tedious
    process of copy-pasting

  - triggering our OCD, we did not like traversing over and over
    again the many files that were all OK just to get to the one
    that was not OK. not only was there a timecost to this that
    increased linearly as development progressed, but this made it
    impractical to set breakpoints etc.



## design consequence

SO, to all of this: the frontend now takes a new option that enables
what we’ll call “corpus mode”:

  - you’ll need to already have your corpus represented as such:

    - each file in the corpus shows up as one line in a text file.
      we may see it as that the corpus is broken up into “small
      pieces” with each such file being one such piece.

    - we also subdivide the corpus into “big pieces”: we represent the
      corpus as several such text files (all in one directory). in our
      case each “big piece” is one sidesystem.

    so there is one file for every sidesystem and each line of that
    file is the path to each asset file in the sidesystem. (it makes
    more sense if you see it.) (we produce this file tree with
    something like:

        tmx map -order after > _CORPUS_ORDER_
        mkdir _CORPUS_
        cat _CORPUS_ORDER_ | while read ss ; do find “$ss” -type [IBID] > “_CORPUS_/$ss” ; done

this “corpus mode” allows you to traverse the corpus in a series of
emergent steps. the first step starts with the first file in the
corpus. if there are no holes in the system against this corpus, it
will proceed from file to file without raising any exceptions and then
exit, in effect completing the traversal in one step.

however if an exception is raised, the current file’s path is written
to disk (as well as other metadata that can be derived from this).
this then serves as the starting point file for the next step. patch
the hole so the system works against this file, run what amounts to
the next step, and so on until you reach the end.

(at writing this won’t clean up the JSON file used to hold the step
state when we complete the traversal, but we will most likely add this.)




## issues :[#here.3]

  2) as referenced in [hu], we encountered an issue with procs needing
     parens for their argument lists for the parser but not MRI..





## document-meta

  - #history-A.1: a blob of document text here started as a commit message.
    aspects of it are written as a commit message in that they refer to
    the ecosystem corpus in its contemporary style.

  - #tombstone-A: sunsetted section about the problem with determining
    ending line numbers using the 'ruby_parser' gem. (was [#here.B]).
    this was a lengthy screed that in fact comprised the whole file. poof!
