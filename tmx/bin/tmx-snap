#!/usr/bin/env ruby -w

# (this started as an alias (called "snap" just because it's monosyllabic
# and available and i suppose it's evocative of "snapshot") that simply
# did something like this:
#
#     alias snap="git add file1 ; git add file2 ; git ci -m '(hardcoded msg)'"
#
# that was it. two hardcoded file paths, add them and commit them. it was
# used for "three laws" development (write ONE test that fails, write code
# that passes ONLY that test, commit, repeat). anyway, we liked the feeling
# of flow that came from it so we're blowing it up into a script here.)

require 'skylab/common'

class TMX_snap

  # -
    # -

      def initialize * five
        argv, _, @sout, @serr, @program_name_string_array = five
        @argv = Common_::Polymorphic_Stream.via_array argv
      end

      def execute
        bc = to_bound_call
        if bc
          x = bc.receiver.send bc.method_name, * bc.args
          if ! x.nil?
            @stderr.puts "(don't - #{ x.class })"
          end
        end
        @exitstatus
      end

      def to_bound_call
        if @argv.no_unparsed_exists
          @exitstatus = NOPE__
          @serr.puts "missing argument - expecting <operation>"
          _express_usage

        elsif HELP_RX__ =~ @argv.current_token
          @exitstatus = YEP__
          __express_help
        elsif __parse_operation_name
          @exitstatus = YEP__
          _m = remove_instance_variable :@__operation_method_name
          _common_init
          Common_::Bound_Call[ nil, self, _m ]
        else
          @exitstatus = NOPE__
          __whine_about_unknown_operation
        end
      end

      def __parse_operation_name

        tok = @argv.current_token
        k = Common_::Name.via_slug( tok ).as_lowercase_with_underscores_symbol
        m = OPERATIONS__[ k ]
        if m
          @argv.advance_one
          @__operation_symbol = k
          @_operation_slug = tok
          @__operation_method_name = m
          ACHIEVED_
        else
          UNABLE_
        end
      end

      def __whine_about_unknown_operation

        tok = @argv.current_token
        @serr.puts "unrecognized operation: #{ tok.inspect }"
        @serr.puts "expecting #{ _say_available_operations }"
        __invite_to_help
      end

      def _express_usage

        _these = _say_available_operations

        @serr.puts "usage: #{ _program_name } #{ _these } [..]"

        NOTHING_
      end

      def __express_help

        _express_usage

        io = @serr
        io.puts

        io.puts "decription: experiment.."

        io.puts
        io.puts "(try -h after the individual operations)"

        NOTHING_
      end

      def _say_available_operations

        _st = __to_operation_slug_stream

        _these = _st.join_into_with_by( "", " | " ) { |s| s }

        "{ #{ _these } }"
      end

      def __to_operation_slug_stream
        Common_::Stream.via_nonsparse_array OPERATIONS__.keys do |sym|
          Common_::Name.via_lowercase_with_underscores_symbol( sym ).as_slug
        end
      end

      # --

      OPERATIONS__ = {
        list: :__at_list,
        add: :__at_add,
        commit: :__at_commit,
      }

      DESCRIPTIONS__ = {
        add: :__describe_add,
        list: :__describe_list,
      }

      # --

      def __describe_list
        io = @serr
        io.puts "usage: #{ _program_name } list"
        io.puts
        io.puts "description: lists the lines of the file (plus \"metadata\")"
        NIL
      end

      def __at_list
        if @argv.no_unparsed_exists
          if __resolve_file_open_for_read
            __do_list
          end
        else
          __maybe_operation_help
        end
      end

      def __do_list

        down_lines = @sout
        fs = @_filesystem
        serr = @serr
        up_lines = @_file_io

        say = -> do
          s = "and "
          say = -> { s }
          "file in #{ @_file } not found: "
        end

        begin
          line = up_lines.gets
          line || break
          line.chomp!

          if fs.exist? line
            down_lines.puts line
            redo
          end

          serr.puts "(#{ say[] }#{ line })"

          redo
        end while above
        NIL
      end

      # --

      def __describe_add
        io = @serr
        io.puts "usage: #{ _program_name } add <file>"
        io.puts
        io.puts "description: add the <file> (line) to the #{ @_file } file"
        NIL
      end

      def __at_add

        if @argv.no_unparsed_exists

          _whine_about_expecting_argument '<file>'
          _invite_to_operation_help

        elsif HELP_RX__ =~ @argv.current_token

          _when_operation_help_requested

        elsif _resolve_file_open_for ::File::CREAT | ::File::RDWR | ::File::APPEND

          __do_add
        end
      end

      def __do_add

        # (sorting the list would be fun but meh)

        count = 0
        argv = @argv
        io = @_file_io
        begin
          _anything = argv.gets_one
          io.puts _anything
          count += 1
        end until argv.no_unparsed_exists
        io.close

        @serr.puts "(added #{ count } lines to #{ io.path })"

        NIL
      end

      def __resolve_file_open_for_read
        _resolve_file_open_for ::File::RDONLY
      end

      def _resolve_file_open_for d
        @_file_io = @_filesystem.open @_file, d
        ACHIEVED_
      rescue ::Errno::ENOENT => e
        @serr.puts e.message.sub( ' @ rb_sysopen', '' )  # EMPTY_S_
        @serr.puts "(use `#{ _program_name } add` to add files)"
        @exitstatus = NOPE__
        UNABLE_
      end

      def _common_init
        @_file = '.snap'
        @_filesystem = ::File
        NIL
      end

      # --

      def _whine_about_expecting_argument moniker

        @serr.puts "expecting #{ moniker } for #{ @_operation_slug }"

        NIL
      end

      def __maybe_operation_help  # assume nonzero-length argv

        tok = @argv.current_token

        if HELP_RX__ =~ tok
          _when_operation_help_requested
        else
          __whine_about_unexpected_argument_for_operation
        end
      end

      def __whine_about_unexpected_argument_for_operation

        @serr.puts "unexpected argument #{ tok.inspect } for #{ @_operation_slug }"
        _invite_to_operation_help
      end

      def _invite_to_operation_help
        @serr.puts "try `#{ _program_name } #{ @_operation_slug } -h`"
        NIL
      end

      def _when_operation_help_requested

        @argv.advance_one

        m = DESCRIPTIONS__[ @__operation_symbol ]
        if m
          send m
        else
          @serr.puts "(no help/description available for #{ @_operation_slug }"
        end
        NIL
      end

      def __invite_to_help

        @serr.puts "try `#{ _program_name } -h`"
        # (skip this for now - it doesn't add anything)
        UNABLE_
      end

      def _program_name
        ::File.basename @program_name_string_array.last
      end

      # --
    # -

    # ==

    ACHIEVED_ = true
    HELP_RX__ = %r(\A--?h(?:e(?:l(?:p)?)?)?\z)
    NOPE__ = 5
    NOTHING_ = nil
    UNABLE_ = false
    YEP__ = 0

    # ==

  # -

  Common_ = ::Skylab::Common
end

if ::File.basename( $PROGRAM_NAME ) == ::File.basename( __FILE__ )

  d = TMX_snap.new(
    ARGV, $stdin, $stdout, $stderr, [ $PROGRAM_NAME ]
  ).execute

  if d.nonzero?
    $stderr.puts "(exitstatus: #{ d })"
  end

  exit d
end
