module Skylab::System

  module Doubles::Stubbed_System

    class Recording  # exacty [#036]

      class << self
        alias_method :via, :new
        undef_method :new
      end  # >>

      def initialize out, real_system

        @_do_wrap_in_modules = nil
        @_do_holler_back = nil

        yield self

        if @_do_wrap_in_modules
          len = @_wrap_in_modules.length
          len += 1
          @_real_out = out
          @out = Indenting_puts_proxy___[ out, '  ' * len ]
        else
          @out = out
        end

        @_is_first = true
        @real_system = real_system
      end

      def holler_back s
        s = s.gsub %r(\A\.#{ ::Regexp.escape ::File::SEPARATOR }), EMPTY_S_
        @_do_holler_back = true
        @_holler_back = s ; nil
      end

      def wrap_in_module * s_a
        if s_a.length.nonzero?
          @_do_wrap_in_modules = true
          @_wrap_in_modules = s_a ; nil
        end
      end

      def popen3 * argv

        if @_is_first
          @_is_first = false
          __output_opening
        end

        if ! @_is_first || @_do_wrap_in_modules
          @out.puts
        end

        @out.puts "o.on #{ argv.inspect } do"

        sin, out, err, wait = @real_system.popen3( * argv )

        CommandRecording___.new( sin, out, err, wait, argv, @out ).to_four
      end

      def __output_opening

        if @_do_wrap_in_modules
          __output_opening_modules
        elsif @_do_holler_back
          _holler_back
        end

        _output_this_text_unindented <<-HERE
          o = Home_.lib_.system_lib::Doubles::Stubbed_System::MockSystem.begin

          o.command_category do |a|
            # in effect don't group commands into categories; there is just one category
            true
          end

          o.command_key do |a|
            # the entire command is its own key
            a
          end
        HERE

        NIL
      end

      def __output_opening_modules

        mutable_current_margin = ""
        indent_by = "  "

        indent = -> do
          mutable_current_margin.concat indent_by
        end

        st = Common_::Stream.via_nonsparse_array @_wrap_in_modules
        s = st.gets
        begin
          @_real_out.puts "#{ mutable_current_margin }module #{ s }"
          s = st.gets
          s || break
          indent[]
          @_real_out.puts
          redo
        end while above

        @_mutable_current_margin = mutable_current_margin

        indent[]

        if @_do_holler_back
          _holler_back
        end

        @_real_out.puts

        @_real_out.puts "#{ mutable_current_margin }Build = -> do"

        @_real_out.puts
        NIL
      end

      def _holler_back

        @_real_out.puts
        _msg = "# (started as generated by #{ @_holler_back })"
        @_real_out.puts "#{ @_mutable_current_margin }#{ _msg }"
        NIL
      end

      def receive_done
        if @_do_wrap_in_modules
          __output_closing_test
        end
        NIL
      end

      def __output_closing_test
        @_real_out.puts
        @out.puts "o.finish"
        begin
          @_real_out.puts "#{ @_mutable_current_margin }end"
          @_mutable_current_margin.length.zero? && break
          @_mutable_current_margin[ -2, 2 ] = EMPTY_S_
          redo
        end while above
        NIL
      end

      def _output_this_text_unindented mutable_big_s
        _String = Home_.lib_.basic::String
        _String.mutate_by_unindenting mutable_big_s
        st = _String.line_stream mutable_big_s
        begin
          line = st.gets
          line || break
          @out.puts line
          redo
        end while above
        NIL
      end

      # ==

      class CommandRecording___

        def initialize psin, psout, pserr, wait, argv, out

          @argv = argv
          @pserr = pserr
          @psout = psout
          @out = out
          @wait = wait

          @_did_out_did_err = {}
          @_receive_exitstatus = :__CANNOT_receive_exitstatus_because_waiting_for_both_streams_to_close
          @_receive_serr = :__receive_first_which_is_serr
          @_receive_sout = :__receive_first_which_is_sout
        end

        def to_four

          serr_proxy = ReadStreamProxy__.new method :__on_serr_gets
          sout_proxy = ReadStreamProxy__.new method :__on_sout_gets
          wait_proxy = WaitProxy___.new method :__on_request_exitstatus

          [ NOTHING_, sout_proxy, serr_proxy, wait_proxy ]
        end

        def __on_serr_gets
          line = @pserr.gets
          send @_receive_serr, line
          line
        end

        def __on_sout_gets
          line = @psout.gets
          send @_receive_sout, line
          line
        end

        def __on_request_exitstatus
          d = @wait.value.exitstatus
          send @_receive_exitstatus, d
          d
        end

        def __receive_first_which_is_serr line
          _on_first_first line, :err, :out, :@_receive_serr, :@_receive_sout
        end

        def __receive_first_which_is_sout line
          _on_first_first line, :out, :err, :@_receive_sout, :@_receive_serr
        end

        def _on_first_first line, stem, stem_, ivar, ivar_
          @_second_stem = stem_
          @_first_ivar = ivar
          @_second_ivar = ivar_
          if line
            _separator_line
            @_did_out_did_err[ stem ] = true
            _begin stem
            instance_variable_set ivar, :_on_subsequent_first
            instance_variable_set ivar_, :__CANT_because_other_stream_is_active
            _on_subsequent_when_line line
          else
            _on_close_of_first_stream
          end
          NIL
        end

        def __mode_change line
          if line
            _separator_line
            @_did_out_did_err[ @_second_stem ] = true
            _begin @_second_stem
            instance_variable_set @_second_ivar, :_on_subsequent_second
            _on_subsequent_second_when_line line
          else
            __on_close_of_second_stream
          end
          NIL
        end

        def _on_subsequent_first line
          if line
            _on_subsequent_when_line line
          else
            _end
            _on_close_of_first_stream
          end
          NIL
        end

        def _on_subsequent_second line
          if line
            _on_subsequent_when_line line
          else
            _end
            _on_close_of_second_stream
          end
        end

        def _on_subsequent_when_line line
          if BLANK_LINE_RX__ =~ line
            @out.puts line
          else
            @out.puts "    #{ line }"
          end
        end

        def _on_close_of_first_stream
          instance_variable_set @_first_ivar, :__CLOSED
          instance_variable_set @_second_ivar, :__mode_change
        end

        def __on_close_of_second_stream
          instance_variable_set @_second_ivar, :__CLOSED
          @_receive_exitstatus = :__receive_only_exitstatus
        end

        def _begin stem
          @out.puts "  _#{ stem } = <<-HERE.unindent"
        end

        def _end
          @out.puts "  HERE"
        end

        def __receive_only_exitstatus d
          @_receive_exitstatus = :__CANNOT_receive_exitstatus_again
          _separator_line
          did = @_did_out_did_err
          if did[ :out ]
            if did[ :err ]
              @out.puts "  [ #{ d }, _out, _err ]"
            else
              @out.puts "  [ #{ d }, _out ]"
            end
          elsif did[ :err ]
            @out.puts "  [ #{ d }, NOTHING_, _err ]"
          else
            @out.puts "  [ #{ d } ]"
          end
          @out.puts "end"
          NIL
        end

        def _separator_line
          @out.puts
        end
      end

      # ==

      class ReadStreamProxy__
        def initialize gets
          @gets = gets
        end
        def gets
          @gets.call
        end
      end

      class WaitProxy___
        def initialize read
          @read = read
        end
        def value
          self
        end
        def exitstatus
          @read.call
        end
      end

      # ==

      Indenting_puts_proxy___ = -> io, indent_string do
        PutsProxy___.new do |s|
          if s && BLANK_LINE_RX__ !~ s
            s = "#{ indent_string }#{ s }"
          end
          io.puts s
          NIL
        end
      end

      BLANK_LINE_RX__ = /\A$/

      class PutsProxy___ < ::Proc
        alias_method :puts, :call
        undef_method :call
      end
    end
  end
end
# #history: born as a blind rewrite of the other one
