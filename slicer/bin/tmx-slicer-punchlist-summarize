#!/usr/bin/env ruby -w

module Skylab

end

module Skylab::Slicer

  module PunchlistSummarize

    class CLI

      def initialize _sin, sout, serr, pn_s_a
        @program_name_string_array = pn_s_a
        @serr = serr
        @sout = sout
      end

      def invoke argv
        case 1 <=> argv.length
        when 0
          tok = argv.fetch 0
          if /\A(?:-h|--help\z)/ =~ tok
            _usage
          else
            @_path = tok
            __execute
          end
        when -1
          @serr.puts "unexpected argument - '#{ argv.fetch 1 }'"
          _usage
        when 1
          @serr.puts "expecting <path>"
          _usage
        end
      end

      def _usage
        @serr.puts "usage: '#{ __program_name } <path>"
      end

      def __program_name
        ::File.dirname @program_name_string_array.last
      end

      # --

      def __execute

        out = @sout
        _fh = ::File.open @_path, ::File::RDONLY
        _st = SectionStream_via_LineStream___[ _fh ]
        st = CategoryStream_via_SectionStream___[ _st ]
        begin
          cat = st.gets
          cat || break
          out.puts "#{ cat.label }:"
          st_ = cat.to_item_stream
          begin
            item = st_.gets
            item || break
            out.puts "  - #{ item.summarize_to_string }"
            redo
          end while nil
          redo
        end while nil
        0
      end
    end

    # ==

    CategoryStream_via_SectionStream___ = -> st do

      h = {}
      a = []
      rx = /[ ]*(?<label>[^:]+[^ ])[ ]*:[ ]*(?<category>.*)/

      current_section_label = nil
      begin
        sec = st.gets
        sec || break
        current_section_label = sec.label
        st_ = sec.to_line_stream
        begin
          line = st_.gets
          line || break
          md = rx.match line
          if ! md
            fail "eek: #{ line.inspect }"
          end
          label = md[ :label ]
          category = md[ :category ]
          _cat = h.fetch category do
            cat_ = Category__.new category
            h[ category ] = cat_
            a.push cat_
            cat_
          end
          _cat.push label, current_section_label
          redo
        end while nil
        redo
      end while nil

      a.sort_by! do |cat|
        cat.item_count
      end

      Stream__.via_nonsparse_array a
    end

    # ==

    class Category__

      def initialize label
        @label = label
        @items = []
      end

      def push label, section_label
        @items.push Item___.new( label, section_label ) ; nil
      end

      def to_item_stream
        Stream__.via_nonsparse_array @items
      end

      def item_count
        @items.length
      end

      attr_reader(
        :label,
      )
    end

    # ==

    class Item___

      def initialize s, s_
        @label = s
        @section_label = s_
      end

      def summarize_to_string
        "#{ @label } (#{ @section_label })"
      end

      attr_reader(
        :label,
        :section_label,
      )
    end

    # ==

    SectionStream_via_LineStream___ = -> fh do

      blank_rx = /\A [[:space:]]* \z/x
      comment_rx = /\A  [[:space:]]*  \#  [ ]* (?<leader>[-]+)? [ ]* (?<content> .+ )  $/x

      magic_section_thing = '--'

      line = nil
      section_matchdata = nil

      Stream__.new do
        begin
          if ! line
            line = fh.gets
            line || break
            if blank_rx =~ line
              line = nil
              redo
            end
          end
          if ! section_matchdata
            md = comment_rx.match line
            if md
              if magic_section_thing == md[ :leader ]
                section_matchdata = md
              end
              line = nil
              redo
            end
          end

          next_next = nil
          a = []
          line and a.push line
          begin
            line = fh.gets
            line || break
            if blank_rx =~ line
              redo
            end
            md = comment_rx.match line
            if md
              if magic_section_thing == md[ :leader ]
                line = nil
                next_next = md
                break
              end
              redo
            end
            a.push line
            redo
          end while nil

          x = Section__.new section_matchdata[ :content ], a
          section_matchdata = next_next  # any
          break
        end while nil
        x
      end
    end

    # ==

    class Section__

      def initialize s, s_a
        @label = s
        @_lines = s_a
      end

      def to_line_stream
        Stream__.via_nonsparse_array @_lines
      end

      attr_reader(
        :label,
      )
    end

    # ==

    class Stream__ < ::Proc

      class << self

        def via_nonsparse_array a
          d = -1 ; last = a.length - 1
          new do
            if d != last
              a.fetch( d += 1 )
            end
          end
        end
      end  # >>

      alias_method :gets, :call
    end
  end
end

exit Skylab::Slicer::PunchlistSummarize::CLI.new( $stdin, $stdout, $stderr, [$PROGRAM_NAME] ).invoke ARGV
