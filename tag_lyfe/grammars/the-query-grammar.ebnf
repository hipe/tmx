@@grammar::ZIPP_ZAPP_BADOOZA

start::TopThing
    =
    payload:item_or_list
    ( s | $ )
    ;

item_or_list::ItemOrList
    =
    left:item right:[conjuncted]
    ;

conjuncted::Conjuncted
    =
    s
    and_or_or:( 'and' | 'or' )
    s ~
    item_or_list:item_or_list
    ;

item
    =
    | negated_function
    | tagging_matcher
    ;

negated_function::NegatedFunction
    =
    'not' s ~
    function_that_is_negated:(
        tagging_matcher
    )
    ;

tagging_matcher::TaggingMatcher
    =
    tagging_path:tagging_path
    modifying_suffix:[s modifying_suffix]
    ;

tagging_path::TaggingPath
    =
    surface_tag:surface_tag
    deep_selector:[deep_selector]
    ;

deep_selector::DeepSelector
    =
    left:deep_selector_component right:[deep_selector]
    ;

deep_selector_component::DeepSelectorComponent
    =
    ':' ~
    deep_selector_rough_stem:deep_selector_rough_stem
    ;

deep_selector_rough_stem
    =
    /[-a-zA-Z0-9_]+/ ~
    # the experimental idea is in the soft pass we'll determine whether
    # it's a value or a sub-tag (we may not distinguish).
    # expert mode will be quoted strings #wish [#707.E]
    ;

surface_tag::SurfaceTag
    =
    '#' ~ tag_stem:tag_stem
    ;

tag_stem
    =
    /[a-z]+/ ~
    # (the above is a very temporary, over-simplified placeholder)
    ;

modifying_suffix
    =
    with_or_without_value
    ;

with_or_without_value::WithOrWithoutValue
    =
    with_or_without:( 'without' | 'with' )
    # (the above isn't pretty on the AST side if you do it the way you want)
    s ~
    'value'
    ;

s = '\0' ;
# (above is NULL_BYTE_)


# #history-A.3: introduce `with value`, `without value`
# #history-A.2: introduce negation
# #history-A.1: add deep selectors (exact match)
# #born.
