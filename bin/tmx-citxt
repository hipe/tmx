#!/usr/bin/env ruby -w

# one-off for writing git commit messages (like git-flow)

module Skylab
end

module Skylab::CI_Txt

  WRITEMODE_ = 'w'.freeze

  module CLI
  end

  class CLI::Client

    def initialize *a
      super
      @is_finished = @pwd = @git_dir_pathname = @dir_pathname_raw = nil
      @is_dry_run = @be_verbose = nil
    end

    def invoke argv
      res = nil
      begin
        ok = nil
        begin
          begin
            option_parser.parse! argv
            @is_finished and break( ok = true )
            if argv.any?
              self.dir_path = argv.shift
            end
            if argv.any?
              emit :help, "unexpected arg(s): #{ argv.inspect }"
              break
            end
            ok = true
          rescue ::OptionParser::ParseError => e
            call_digraph_listeners :help, e.message
          end
        end while nil
        if ! ok
          emit :help, usage_line
          emit :help, invite_line
          break
        end
        res = execute unless @is_finished
        if false == res
          emit :help, invite_line
        end
      end while nil
      res
    end

  private

    ref_rx = /\Aref: ([^\n]+)\n\z/

    define_method :branch_name do
      res = nil
      begin
        head_pathname = @git_dir_pathname.join 'HEAD'
        content = head_pathname.read
        unless ref_rx =~ content
          send_error_string "failed to read content of #{ escape_path head_pathanme }"
          res = false
          break
        end
        whole = $~[1]
        res = whole.split( '/' ).last
      end
      res
    end

    filename = 'ci.txt'

    define_method :build_option_parser do
      require 'optparse'
      o = ::OptionParser.new

      o.base.long[ 'ping' ] = ::OptionParser::Switch::NoArgument.
        new( & method( :ping ) )

      o.on '-n', '--dry-run', 'dry run.' do
        @is_dry_run = true
      end

      o.on '-v', '--verbose', 'be verbose.' do
        @be_verbose = true
      end

      o.banner = <<-HERE.gsub( /^        /, '' )
        #{ usage_line }

        #{ em 'description:' } creates a #{ filename } file.

        #{ em 'options:' }
      HERE
      o
    end

    def ping _
      @infostream.puts "hello from citxt."
      @is_finished = true
      nil
    end

    define_method :create_initial_file do
      res = nil
      begin
        use_dir = nil
        if @dir_pathname_raw
          if ! dir_pathname_expanded.directory?
            send_error_string "#{ em param_label } must be directory: #{ @dir_pathname_raw }"
            break( res = false )
          end
          inside = dir_pathname_expanded.to_s
          outside = @git_dir_pathname.dirname.to_s
          if 0 != inside.index( outside )
            send_error_string "#{ inside } must be inside #{ outside }"
            break( res = false )
          end
          use_dir = dir_pathname_expanded
        else
          use_dir = @git_dir_pathname.dirname
        end
        pathname = use_dir.join filename
        if pathname.exist?
          fail 'sanity'
        end
        branch_name = self.branch_name or break
        first_line = "[##{ branch_name }]"
        send_info_string( first_line ) if @be_verbose
        bytes = nil
        if @is_dry_run
          bytes = 0
        else
          pathname.open( WRITEMODE_ ) do |fh|
            bytes = fh.write "#{ first_line }\n\n  + " # etc
          end
        end
        send_info_string "created #{ escape_path pathname } (#{ bytes } bytes)"
        res = pathname
      end while nil
      res
    end

    def dir_path= str
      require 'pathname'
      @dir_pathname_raw = ::Pathname.new str
      str
    end

    def dir_pathname_expanded  # assumes `dir_pathname_raw`
      @dir_pathname_expanded ||= dir_pathname_raw.expand_path
    end

    define_method :execute do
      res = nil
      begin
        @git_dir_pathname = find_git_dir or break
        existing = find_existing
        if existing
          if @dir_pathname_raw
            if ! reconcile_dir_pathname_with_existing existing
              res = false
              break
            end
          end
          send_info_string "using #{ escape_path existing }"
        else
          existing = create_initial_file
          existing or break( res = existing )
        end
        editor = ::ENV['EDITOR'] || 'vi'
        cmd = "#{ editor } #{ escape_path existing }"
        if @is_dry_run
          send_info_string "would have executed `#{ cmd }`"
        else
          exec cmd
        end
      end while nil
      res
    end

    define_method :find_existing do
      curr = @pwd
      stop = @git_dir_pathname.dirname
      if ! @pwd.to_s.index( stop.to_s )  # is pwd equal to or under stop dir?
        fail 'sanity'
      end
      found = nil
      loop do
        try = curr.join filename
        if try.exist?
          found = try
          break
        end
        if curr == stop
          break
        end
        curr = curr.dirname
      end
      found
    end

    git_dir_basename = '.git'

    define_method :find_git_dir do
      require 'pathname'
      curr = @pwd = ::Pathname.pwd
      found = false
      seen = [ ]
      loop do
        try = curr.join git_dir_basename
        if try.exist?
          found = try
          break
        end
        seen.push curr.basename
        parent = curr.dirname
        if parent == curr
          break
        else
          curr = parent
        end
      end
      if ! found
        send_error_string "couldn't find #{ em git_dir_basename } directory anywhere from #{
          }pwd (\"#{ pwd }\") up to \"/\" (#{ seen.length } dirs)"
      end
      found
    end

    param_label = '<dir_to_create_file_in>'

    define_method :param_label do param_label end

    define_method :reconcile_dir_pathname_with_existing do |existing|
      if dir_pathname_expanded == existing.dirname
        true
      else
        send_error_string "couldn't reconcile filenames - #{
        }you specified a #{ em param_label } (#{ @dir_pathname_raw }), #{
        }but an existing #{ filename } was found (#{ escape_path existing }) #{
        }and it was not in that directory. Either don't specify the path or #{
        }move the file to where you want it."
        false
      end
    end

    define_method :usage_line do
      "#{ em 'usage:' } #{ program_name } [-h] [-v] [ #{ param_label } ]"
    end
  end


  module CLI
    def self.new *a
      CLI::Client.new(* a)
    end
  end


  module CLI::Client::InstanceMethods

  private

    def initialize _, paystream, infostream
      @infostream = infostream
      @paystream = paystream
    end

    def em str
      "\e[1;32m#{ str }\e[0m"
    end

    def emit type=:info, str
      instance_variable_get( :payload == type ? :@paystream : :@infostream ).
        puts str
      nil
    end

    def send_error_string msg
      emit :error, "couldn't #{ em program_name } - #{ msg }"
      false
    end

    def escape_path pathname
      pathname.relative_path_from( @pwd ).to_s
    end

    def send_info_string msg
      emit :info, "#{ em program_name } #{ msg }"
      nil
    end

    def invite_line
      "try #{ em "#{ program_name } -h" } for help"
    end

    def option_parser
      @option_parser ||= build_option_parser
    end

    def program_name
      ::File.basename $PROGRAM_NAME
    end
  end

  class CLI::Client
    include CLI::Client::InstanceMethods
  end
end

Skylab::CI_Txt::CLI.new( $stdin, $stdout, $stderr ).invoke ARGV
