#!/usr/bin/env ruby -w

require 'strscan'
require 'optparse'
require 'pathname'
require 'stringio'

# unit test(s):
# rspec lib/skylab/bnf2treetop/test

# The implementation of this is a tribute to all the hand-written top-down
# recursive descent parsers of the world.

module Skylab ; end
module Skylab::Bnf2Treetop

  Param = ::Struct.new(:name, :arg_stem, :bool, :default, :list, :desc)
  P = ->(n, o=nil) { p = Param.new(n) ; o and o.each { |k, v| p[k] = v } ; p }
  PARAMS = [
    P[:equals_terminal,
       default: '::=',
       arg_stem: 'token',
       desc: ['Use this alternative "equals thingy" when parsing',
              'the input grammar{{default}}']
    ],
    P[:squares,
       bool: true,
       desc: ['Use square brackets to indicate optional clauses',
              '(So then [foo] is shorthand for (foo)?.',
              'Now you can\'t use character classes.)']
    ],
    P[:grammar,
      arg_stem: 'name',
      desc: ['Nest the treetop output in this grammar',
             'declaration (e.g. "Mod1::Mod2::Grammar")']
    ],
    P[:include,
      arg_stem: 'module',
      list: true,
      desc: ['The treetop output grammar will include',
             'this (these) modules']
    ],
    P[:literalize_unicode,
       bool: true,
       default: true,
       desc: "Output unicode glyphs as opposed\nto number codes{{default}}"
    ],
    P[:rule_prefix,
       desc: '{{arg_label}} will be prepended as-is to rule names.'
    ],
    P[:uncamelize,
       bool: true,
       default: true,
       desc: ['Whether to convert names from camel-case',
              'to underscore{{default}}']
    ],
    P[:sexp,
       bool: true,
       desc: 'Suppress normal output.  show grammar sexp.'
    ]
  ]
  PARAM = ::Hash[ * PARAMS.map { |p| [p.name, p] }.flatten ]

  TAB_STR = '  ' # will be used for indenting, creating margins in treetop g.

  module Headless end
  module Headless::Client_InstanceMethods
  protected
    def error msg ; emit(:error, msg) ; false end
    def info msg ; emit(:info, msg) end
    def or_  list ; oxford_comma(list, ' or ') end
    def oxford_comma items, last_glue = ' and ', rest_glue = ', '
      items.zip(
        items.size < 2 ? [] :
          ( [last_glue] + ::Array.new(items.size - 2, rest_glue) ).reverse
      ).flatten.join
    end
    def s_ a ; a.length == 1 ? '' : 's' end
  end

  module CLI
    def self.new(*a, &b) ; CLI::Client.new(*a, &b) end
  end

  module CLI::Client_InstanceMethods
    include Headless::Client_InstanceMethods
    def invoke argv
      parse_argv!(argv) and headless_client.execute
    end
    attr_writer :program_name
  protected
    # the grand experiment revisited
    def build_option_parser
      op = ::OptionParser.new
      op.separator em('options:')
      args = [] ; arg_label = nil
      desc_f = ->(p) do
        a = (::Array === p.desc ? p.desc : [p.desc]).reduce([]) do |m, s|
          m.concat s.split("\n")
          m
        end
        a.map! do |s|
          s.gsub(/\{\{((?:(?!\}\}).)+)\}\}/) do
            case $1
            when 'arg_label' ; arg_label
            when 'default'   ; " (default: #{p.default})"
            end
          end
        end
        args.concat a
      end
      single_letter_taken = ::Hash.new do |h, k|
        args.push "-#{k}"
        h[k] = true
      end
      single_letter_taken['h'] = true
      formal_parameters.each do |p|
        args.clear
        name = p.name.to_s
        single_letter_taken[name[0, 1]] unless (p.bool and true == p.default)
        label = "#{name.gsub('_', '-')}"
        arg_label = "<#{ (p.arg_stem || name.split('_').last) }>"
        args.push( if p.bool
                 if true == p.default then  "--[no-]#{ label }"
                 else                       "--#{ label }"
                 end
               else "--#{ label }=#{ arg_label }"
               end )
        p.desc and desc_f.call p
        op.on(*args) { |v| invocation_parameters.push([p.name, v]) }
      end
      op.on('-h', '--help', 'Show this message') { queue.push :help }
      op.on('--version', 'Show version') { queue.push :version }
      op.banner = usage_line
      op
    end
    def help ; infostream.puts option_parser.help end
    def invocation_parameters; @invocation_parameters ||= [] end
    def noop ; end # does nothing, is logically useful
    def option_parser ; @option_parser ||= build_option_parser end
    def parse_argv! argv
      parse_opts!(argv) && parse_args!(argv) or return
      headless_client.invocation_parameters = invocation_parameters
      @invocation_parameters = nil
      true
    end
    def parse_opts! argv
      begin
        option_parser.parse! argv
      rescue ::OptionParser::ParseError => e
        usage e.message
        queue.clear.push :noop # indicates that all necessary action is complete
      end
      if queue.empty?
        true # continue on to parse_args! and execute
      else
        begin ; send(queue.shift) end until queue.empty?
        nil # do not parse_args!, all action is complete
      end
    end
    def program_name
      (@program_name ||= nil) || File.basename($PROGRAM_NAME)
    end
    def queue ; @queue ||= [] end
    def usage msg=nil
      msg and emit(:usage, msg)
      emit(:usage, usage_line)
      emit(:usage, "#{em "#{program_name} -h"} for help")
      false
    end
    def version ; infostream.puts("#{program_name} #{version_string}") end
    # --*--
    CODES = { bold: 1, green: 32 }
    def stylize str, *a           # away at [#bn-005]
      "\e[#{ a.map{ |s| CODES[s] }.compact.join(';') }m#{str}\e[0m"
    end
    def em str ; stylize(str, :bold, :green ) end
  end

  class CLI::Client < ::Struct.new(:paystream, :infostream, :upstream,
                                   :headless_client)
    include CLI::Client_InstanceMethods
    def initialize paystream=$stdout, infostream=$stderr
      super paystream, infostream, nil, Headless::Client.new(self)
    end
    def emit type, string
      (:payload == type ? paystream : infostream).puts string
    end
  protected
    def formal_parameters ; PARAMS end
    attr_reader :in_pathname
    INFILE = '<bnf-file>'
    def parse_args! argv
      1 == argv.length or
        return usage("expecting #{INFILE} had #{argv.length} args")
      @in_pathname = ::Pathname.new(argv.shift)
      if '-' == in_pathname.to_s
        $stdin.tty? and return usage("Expecting STDIN to be a stream.")
        self.upstream = $stdin
      else
        in_pathname.exist? or return usage("file not found: #{in_pathname}")
        self.upstream = ::StringIO.new(in_pathname.read) # heh heh
      end
      true
    end
    def usage_line
      "#{em 'usage'}: #{program_name} [options] { #{INFILE} | - }"
    end
    def version_string ; '0.0.0' end
  end

  module API
    def self.translate request_h
      request_h = request_h.dup
      rt = API::RequestRuntime.new( * # request can hold both kinds of params
        API::RequestRuntime.members.map { |m| request_h.delete(m) }
      )
      hc = Headless::Client.new rt
      hc.invocation_parameters = request_h.map { |k, v| [k.intern, v] }
      hc.execute
    end
  end
  class API::RequestRuntime < ::Struct.new(:paystream, :infostream, :upstream)
    def emit t, d ; (:payload == t ? paystream : infostream).puts d end
  end

  class Headless::Client < ::Struct.new(
    :margin, # --*--
    :expecting, :invocation_parameters,
    :tree, :request_runtime, :scn, * PARAMS.map(&:name)
  )

    include Headless::Client_InstanceMethods
    def initialize request_runtime
      super(nil, [], nil, [:rules], request_runtime)
      self.margin = TAB_STR # overwritten on "grammar" parameter
      PARAMS.each { |p| p.default.nil? or self[p.name] = p.default }
      @stack = [tree]
    end
    def execute
      self.scn = ::StringScanner.new(upstream.read)
      upstream.close
      modeline! or return
      absorb! or return
      space!
      ok = catch :stop do
        grammar and grammar_prepare
        include and include_prepare
        until scn.eos?
          new_rule!
          rule_name! ; white! ; equals_thingy! ; white! ; rule_rhs! ; white!
          space!
        end
        true
      end
      if sexp then
        require 'pp'
        PP.pp(tree, paystream)
        return true
      end
      if ok
        grammar and grammar_write_treetop_begin
        include and include_write
        Nodes::Rules.new(tree, self, paystream, infostream).write_treetop
        grammar and grammar_write_treetop_end
      end
    end
  protected
    # --*--
    def emit(type, data) ; request_runtime.emit(type, data) end
    def formal_parameters ; PARAMS end
    def infostream ; request_runtime.infostream end
    def paystream ; request_runtime.paystream end
    def upstream ; request_runtime.upstream end
    # --*--
    def absorb!
      [modeline_parameters, invocation_parameters].compact.each do |params|
        params.each do |name, value|
          if PARAM[name].list
            self[name] ||= []
            if ::Array === value
              self[name].concat(value)
            else
              self[name].push value
            end
          else
            self[name] = value
          end
        end
      end
      true
    end
    CONTEXT = 20
    def fail_with_context msg
      info msg
      after = scn.peek CONTEXT
      before = scn.string[ [0, scn.pos - CONTEXT].max ... scn.pos ]
      clean_f = ->(s) { s.gsub("\n", ' ') }
      before = clean_f[before] ; after = clean_f[after]
      info "at: #{ before }#{ after }"
      info "----#{ '-' * before.length }^"
      scn.eos? and info("(before end of input)")
      throw :stop, false
    end
    # Don't advance scan pointer, just check if the first line has a modeline
    # and if it does, process it immediately
    # and then (ick) invocation_parameters
    def modeline!
      (modelines = modeline_parse!) == false and return false
      if modelines
        list_f = ->(a) do
          a.map do |n, v|
            true == v ? n : "#{ n }=#{ /[ \t=:]/ =~ v ? v.inspect : v }"
          end.join(' ')
        end
        info "(using file's modeline parameters: #{ list_f[modelines] })"
        begin # this is all porcelain, grouped only for semantics
          order = [ ]
          values = (modelines + invocation_parameters).reduce(
            ::Hash.new { |h, k| order.push k ; h[k] = [] }
          ) { |m, pair| m[pair.first].push pair.last ; m }
          a = order.select{|k| 1 < values[k].length}.map{|k| [k, values[k][1]]}
          if ! a.empty?
            info( "(modeline parameter#{s_ a} overridden by #{
              }invocation parameter#{s_ a}: #{ list_f[a] })" )
          end
        end
      end
      @modeline_parameters = modelines
      true
    end
    attr_reader :modeline_parameters
    # An attempt at a faithful re-implementation of vim's modeline syntax.
    # (See vim's ":help modeline" --  we are using "The second form".)
    def modeline_parse!
      line = self.scn.check_until(EOL_RX) or return # peek first line
      scn = ::StringScanner.new(line) # sure why not
      scn.skip(COMMENT_BEGIN_RX) or return # first line is not a comment
      scn.skip_until(/[ \t]bnf2treetop:[ \t]*set?[ \t]/) or return
      fail_f = ->(msg) do
        error("failed to parse modeline: #{msg} at #{scn.peek(10).inspect}")
      end
      sexp = []
      loop do
        scn.skip(/[ \t]+/)
        scn.skip(/:/) and break
        name = scn.scan(/[_a-z]+/) or
          return fail_f["expecing ':' or option name"]
        sexp.push([name])
        if scn.skip(/=/)
          if (q = scn.scan(/['"]/))
            content = scn.scan(/(?:\\#{q}|[^#{q}])*/) or fail('sanity')
            scn.skip(/#{q}/) or return fail_f["expecting #{q.inspect}"]
          else
            content = scn.scan(/[^ \t:]+/) # failed match ok, means nillify
          end
          sexp.last.push content # should always be putting it in the [1] spot
        end
      end
      sexp.map do |name, *a|
        matcher = /\A#{ ::Regexp.escape name }#{ '\z' if 1 < name.length }/
        fp = formal_parameters.detect { |_fp| _fp.name.to_s =~ matcher } or
          return error("No such parameter #{name.inspect} (in modeline)")
        [fp.name, a.empty? ? true : a.first]
      end
    end

    def new_rule!
      sexp = [:rule]
      push sexp                 # append sexp to sexp at the top of stack
      stack.push sexp           # make new sexp be new top of stack
    end
    def one_of_or_fail &block
      reset_expecting!
      if found = block.call
        reset_expecting!
        found
      else
        fail_with_context("Expecting #{or_ expecting.map(&:to_s)}")
      end
    end
    def push sexp
      stack.last.push sexp
    end
    def reset_expecting!
      expecting.clear
    end
    attr_reader :stack
    # --*--
    const_rx = '[A-Z][A-Za-z0-9_]*'
    CONST_RX = /\A#{const_rx}\z/
    CONSTANT_RX = /\A(?:::)?#{const_rx}(?:::#{const_rx})*\z/
    def grammar_prepare
      @g_money = grammar.split('::').map do |s|
        CONST_RX =~ s or begin
          info "invalid ruby constant name #{s.inspect}, try e.g. 'FooBar_123'"
          throw :stop, false
        end
        s
      end
      @g_money.empty? and return (self.grammar = nil) # couches
    end
    def grammar_write_treetop_begin
      mods = @g_money[0..-2] ; g = @g_money[-1] ; indent = 0
      if mods.any?
        indent += 1
        paystream.puts "module #{mods.join('::')}"
      end
      paystream.puts "#{TAB_STR * indent}grammar #{g}"
      @g_level = indent + 1
      self.margin = TAB_STR * @g_level
    end
    def grammar_write_treetop_end
      until @g_level <= 0
        @g_level -= 1
        paystream.write("\n#{TAB_STR * @g_level}end")
      end
    end
    def include_prepare
      if nope = include.detect { |x| CONSTANT_RX !~ x }
        info "your include term looks funny: #{nope.inspect}"
        throw :stop, false
      end
    end
    def include_write
      include.each do |s|
        paystream.puts "#{margin}include #{s}"
      end
    end
    # --*--
    COMMENT_BEGIN_RX = /[[:space:]]*#+/
    EOL_RX = /$\r?\n?/
    def space!
      loop do
        white!
        if scn.skip COMMENT_BEGIN_RX
          if _ = scn.scan(/[ \t]*\(output[ \t]+
              (?: '(?:\\'|(?!>').)*' | "(?:\\"|(?!>").)*" )
            [ \t]*\) /x)
            md = _.match(/\A[ \t]*\(output[ \t]+
              (?: '(?<_>(?:\\'|(?!>').)*)' | "(?<_>(?:\\"|(?!>").)*)" ) /x )
            paystream.puts("# #{md[:_]}") # just a q & d p.o.c
          end
          scn.skip_until EOL_RX
        else
          break
        end
      end
      true
    end
    def white!
      scn.skip(/[ \t\n\r\f]+/) || true
    end
    def rule_name!
      n = _rule_name! or fail_with_context("expected Rule Name")
      push n
    end
    def _rule_name!
      expecting << :rule_name
      if str = scn.scan(/[_a-zA-Z][_a-zA-Z0-9]*/) then [:rule_name, str] end
    end
    def equals_thingy!
      _equals_thingy! or
        fail_with_context("expected #{equals_terminal.inspect}")
    end
    def _equals_thingy!
      scn.skip equals_terminal_rx
    end
    def equals_terminal= x ; @equals_terminal_rx = nil ; super end
    def equals_terminal_rx
      @equals_terminal_rx ||= /#{::Regexp.escape equals_terminal}/
    end
    def rule_rhs!
      sexp = [:rhs]
      push sexp
      stack.push sexp
      rhs!
      stack.pop # pop the rhs
      stack.pop # pop the rule!!
    end
    def rhs!
      got = one_of_or_fail {
        _rule_name! || _character_class! || _nonempty_quoted_string! ||
        _unicodepoint_literal! || _parenthesized_group!
      }
      if ::Symbol === got.first
        push got
      else
        got.each { |g| push g }
      end
      white!
      if scn.eos?        then return end
      if scn.check(/\)/) then return end # never processed here
      if squares and scn.check(/\]/) then return end
      reset_expecting!
      expecting << :end_of_input # maybe not used
      need_moar = false
      if got = _kleene!
        push got
        white!
        if scn.eos? then return end
      end
      if got = _or!
        push got
        need_moar = true
        white!
      end

      # ad-hoc lookahead to determine if rule name in LHS or RHS:
      # this way we don't need to care about use of newlines or really any
      # other whitespace

      noted = scn.pos
      if (! need_moar && got = _rule_name! && white! &&
          _equals_thingy! && stack[stack.size-2].first == :rule )
      then
        scn.pos = noted # if a symbol name followed by a '::=', rewind, done
        return
      end
      scn.pos = noted # rewind no matter what! let other call handle rhs symbol
      rhs!
    end
    def _parenthesized_group!
      expecting << :parenthesized_group
      if scn.scan(/\(/) or squares && (b = scn.scan(/\[/))
        nu = [:parenthesized_group]
        # push nu sort of up in the air about whether to do this early or late
        stack.push nu
        white!
        rhs!
        white!
        if b
          one_of_or_fail { expecting << ']'; scn.scan(/\]/) }
        else
          one_of_or_fail { expecting << ')'; scn.scan(/\)/) }
        end
        have = stack.pop
        if b
          if 2 == have.length # one child in a parenthesized group
            have = have.last  # ick
          end
          have = [have, [:kleene, '?']] # sketchlund
        end
        have
      end
    end
    def _character_class!
      squares and return
      expecting << :character_class
      if found = scn.scan(/\[(?:[^\]]|\\\])+\]/)
        [:character_class, found]
      end
    end
    def _kleene!
      expecting << :kleene
      if found = scn.scan(/[*+?]/)
        [:kleene, found]
      end
    end
    def _nonempty_quoted_string!
      expecting << :nonempty_quoted_string
      if found = scn.scan(/'(?:\\'|[^'])+'/)
        [:nonempty_quoted_string, found]
      elsif found = scn.scan(/"(?:\\"|[^"])+"/)
        [:nonempty_quoted_string, found]
      end
    end
    def _or!
      expecting << :or
      if found = scn.scan(/\|/)
        [:or, found]
      end
    end
    def _unicodepoint_literal!
      expecting << :unicodepoint_literal
      if found = scn.scan(/#x([a-zA-Z0-9]+)/)
        [:unicodepoint_literal, found]
      end
    end
  end
  module Nodes
    module Helper_InstanceMethods
      def literalize_unicode str
        str.gsub(/#x([a-zA-Z0-9]+)/){ [$1.hex].pack('U*') }
      end
      def uncamelize str
        str.gsub(/([a-z])([A-Z])/){ "#{$1}_#{$2}" }.downcase
      end
    end
    class Node < ::Struct.new(:tree, :params, :paystream, :infostream)
      include Helper_InstanceMethods
    protected
      def write string ; paystream.write(string) end
    end
    class Rules < Node
      def write_treetop
        flyweight = Rule.new(nil, params, paystream, infostream)
        tree[1..-1].each_with_index do |child_tree, idx|
          0 == idx or write("\n")
          flyweight.tree = child_tree
          flyweight.write_treetop
        end
        true
      end
    end
    class Rule < Node
      def initialize *a
        super(*a)
        @rhs = RHS.new(nil, params, paystream, infostream)
      end
      def write_treetop
        margin = params.margin
        paystream.puts "#{margin}rule #{rule_name}"
        paystream.write "#{margin}#{TAB_STR}"
        tree[2] or return false
        rhs.tree = tree[2]
        rhs.write_treetop
        paystream.write "\n#{margin}end"
        nil
      end
      def rule_name
        str = tree[1][1]
        params.uncamelize and str = uncamelize(str)
        params.rule_prefix and str = "#{params.rule_prefix}#{str}"
        str
      end
    protected
      attr_reader :rhs
    end
    class RHS < Node
      def write_treetop
        write_expression tree
      end
      def write_expression node
        node[1..-1].each_with_index do |_sexp, idx|
          send("_#{_sexp.first}", _sexp, idx)
        end
      end
      def _character_class sexp, idx
        0 == idx or write(' ')
        str = sexp[1]
        params.literalize_unicode and str = literalize_unicode(str)
        write str
      end
      def _kleene sexp, idx
        write sexp[1]
      end
      def _nonempty_quoted_string sexp, idx
        0 == idx or write(' ')
        write sexp[1] # careful!
      end
      def _or _, __
        write(' /')
      end
      def _parenthesized_group sexp, idx
        0 == idx or write(' ')
        write '('
        write_expression sexp
        write ')'
      end
      def _rule_name sexp, idx
        0 == idx or write(' ')
        str = sexp[1]
        params.uncamelize and str = uncamelize(str)
        params.rule_prefix and str = "#{params.rule_prefix}#{str}"
        write str
      end
      def _unicodepoint_literal sexp, idx
        0 == idx or write(' ')
        str = sexp[1]
        params.literalize_unicode and str = literalize_unicode(str)
        write str.inspect # careful!
      end
    end
  end
end

if $PROGRAM_NAME == __FILE__
  ::Skylab::Bnf2Treetop::CLI.new.invoke(ARGV)
end
