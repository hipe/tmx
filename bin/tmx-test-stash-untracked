#!/usr/bin/env ruby -w

require_relative '../lib/skylab'
require 'skylab/test-support/core'

module Skylab
  module Test
  end
end

module Skylab::Test
  class Stash_Untracked
    def initialize i, o, e
      @i = i ; @o = o ; @e = e
      @be_verbose = false
      @do_reverse = false
      @is_dry_run = false
      @match_a = nil
    end
    attr_accessor :program_name
    def invoke argv
      @argv = argv
      es = parse_opts
      es ||= parse_argv
      es || execute
    end
  private
    def parse_opts
      require 'optparse'
      res = nil
      op = ::OptionParser.new
      op.on '-r', '--reverse',  'move files back' do
        @do_reverse = true
      end
      op.on '-n', '--dry-run', 'dry run' do
        @is_dry_run = true
      end
      op.on '-v', '--verbose', 'verbose output' do
        @be_verbose = true
      end
      op.on '-h', '--help', 'this screen.' do
        io = @e
        io.puts usage_line
        io.puts "#{ em 'summary:' } any \"*#{ suffix }\" #{
          }files that are not yet versioned,"
        io.puts "         it will move them to \"*#{ suffix_modified }\"."
        io.puts "#{ em 'options:' }"
        op.summarize @e
        res = GENERAL_SUCCESS__
      end
      begin
        op.parse! @argv
      rescue ::OptionParser::ParseError => e
        @e.puts e.message
        @e.puts invite_line
        res = GENERAL_ERROR__
      end
      res
    end

  private

    def usage_line
      "#{ em 'usage:' } #{ usage_string }"
    end

    def usage_string
      "#{ program_name } [-r]"
    end

    def invite_line
      "try #{ em "#{ program_name } -h" } for help"
    end

    def em s
      "\e[32;1m#{ s }\e[0m"
    end

    def suffix
      @suffix ||= bld_suffix
    end

    def suffix_modified
      @suffix_modified ||= bld_suffix_modified
    end

    def bld_suffix
      bld_sfx @do_reverse
    end

    def bld_suffix_modified
      bld_sfx ! @do_reverse
    end

    def bld_sfx do_reverse
      suffix = ::Skylab::TestSupport::FUN::Spec_rb[]
      if do_reverse
        pn = ::Pathname.new suffix
        base = pn.sub_ext( EMPTY_S_ ).to_path
        ext = pn.extname
        "#{ base }_#{ ext }"
      else
        suffix
      end
    end

    def parse_argv
      if @argv.length.nonzero?
        @e.puts "unexpected argument: '#{ @argv.first }'"
        @e.puts usage_line
        @e.puts invite_line
        GENERAL_ERROR__
      end
    end

    def execute
      es = exc_git_cmd
      es ||= the_rest
    end

    def exc_git_cmd
      require 'open3'
      cmd_a = %w( git ls-files --others --exclude-standard )
      rx = get_rx
      es = ::Open3.popen3( * cmd_a ) do |i, o, e, w|
        saw = nil
        line = o.gets
        while line
          saw ||= true
          line.chomp!
          if (( md = rx.match line ))
            add_match md, line
            @be_verbose and mark = MARK__
          elsif @be_verbose
            mark = nil
          end
          @be_verbose and @e.puts "(#{ line })#{ mark }"
          line = o.gets
        end
        s = e.read
        s.length.nonzero? and break bork( "unexpected - #{ s }" )
        if ! saw
          bork "was expecting output from patch."
        end
        w.value.exitstatus
      end
      if es.nonzero?
        es
      elsif ! @match_a
        @e.puts "no unversioned spec files. nothing to do."
        GENERAL_SUCCESS__
      end
    end

    MARK__ = "  <---".freeze

    def get_rx
      /\A(.+)#{ ::Regexp.escape suffix }\z/
    end

    def add_match md, line_s
      ( @match_a ||= [] ).push md
    end

    def the_rest
      fu = FU__.new @e
      @match_a.each do |md|
        tgt = "#{ md[1] }#{ suffix_modified }"
        fu.mv md[0], tgt, verbose: true, noop: @is_dry_run
      end
      @e.puts "done#{ ' (dry run)' if @is_dry_run }."
      GENERAL_SUCCESS__
    end

    EMPTY_S_ = ''.freeze
    GENERAL_ERROR__ = 5
    GENERAL_SUCCESS__ = 0
  end

  class FU__
    require 'fileutils'
    include ::FileUtils
    public :mv

    def initialize io, label=nil
      @fileutils_output = io
      @fileutils_label = label
    end
  end
end

app = Skylab::Test::Stash_Untracked.new $stdin, $stdout, $stderr
app.program_name = $PROGRAM_NAME
exit app.invoke ::ARGV
