#!/usr/bin/env ruby -w

# class Skylab::Git
#   model Models_::Whatever
#     class Unrename < Action_
#       class Some_Actor


class Skylab_Git_Models_Whatever_Unrename

        def initialize _, o, e, a, pn

          @argv = a
          @do_forward = true
          @pairs = []
          @program_name = ::File.basename pn
          @serr = e
          @sout = o
        end

        def execute

          ok = __parse_argv
          ok &&= __resolve_commit
          ok && __via_commit
        end

        def __parse_argv
          _ok = __parse_opts
          _ok && __parse_args
        end

        def __parse_opts

          require 'optparse'

          op = ::OptionParser.new

          op.on '-R', '--reverse',
              'reproduce the original `mv` statements' do

            @do_forward = false
          end


          x = ACHIEVED_
          op.on '--help', 'this screen' do

            @serr.puts "synopsis: output the text for the git commands that\n#{
              }          unrename (or rename) files per the renames in the commit\n\n"

            @serr.puts "usage: #{ @program_name } [ -R ] <commit>"

            @serr.puts

            @serr.puts 'options:'

            op.summarize @serr

            @serr.puts "example:"
            @serr.puts "    #{ @program_name } HEAD#{ SPACE_ * 12 }#{
              }# produces unrenames for renames in HEAD commit"

            x = CEASE_
          end

          begin
            op.parse! @argv
          rescue ::OptionParser::ParseError => e
            @serr.puts e.message
            __invite
            x = UNABLE_
          end

          x
        end

        def __parse_args
          case 1 <=> @argv.length
          when 0
            @commit_reference_s = @argv.fetch 0
            ACHIEVED_
          when -1
            @serr.puts "unpexpected argument: #{ @argv[ 1 ].inspect }"
            __invite
            UNABLE_
          when  1
            @serr.puts "expectin <commit>"
            __invite
            UNABLE_
          end
        end

        def __invite
          @serr.puts "see '#{ @program_name } --help'"
          nil
        end

        def __resolve_commit

          require_relative '../lib/skylab'
          require 'skylab/git-viz/core'

          @repo = ::Skylab::GitViz.repository.new_via_path( ::Dir.pwd )

          @ci = @repo.fetch_commit_via_identifier @commit_reference_s  # etc
          @ci && ACHIEVED_
        end

        def __via_commit

          exe = @repo.vendor_program_name

          p = if @do_forward
            -> fc do
              @sout.puts "#{ exe } mv #{ fc.destination_path } #{ fc.source_path }"
            end
          else
            -> fc do
              @sout.puts "#{ exe } mv #{ fc.source_path } #{ fc.destination_path }"
            end
          end

          st = @ci.to_filechange_stream.reduce_by do | fc |
            fc.is_rename
          end

          fc = st.gets
          if fc
            begin
              p[ fc ]
              fc = st.gets
              fc or break
              redo
            end while nil
            @serr.puts 'done.'
            ACHIEVED_
          else
            @serr.puts "no renames in #{ @commit_reference_s.inspect }?"
            UNABLE_
          end
        end

        ACHIEVED_ = true
        CEASE_ = nil
        SPACE_ = ' '
        UNABLE_ = false

  self
end.new( $stdin, $stdout, $stderr, ::ARGV, $PROGRAM_NAME ).execute
