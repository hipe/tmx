#!/usr/bin/env ruby -w

requiet = ->(s) { _ = $VERBOSE ; $VERBOSE = nil ; require(s) ; $VERBOSE = _ }

require 'optparse'
require 'pathname'
require 'strscan'
requiet['treetop']

# visual test cases: provide the below FIXTURES as arg1 from command line.

module Skylab end
module Skylab::FlexToTreetop

  VERSION = '0.0.1'
  FIXTURES = {}
  FIXTURES[:mini]   = 'lib/skylab/code-molester/test/fixtures/flex/mini.flex'
  FIXTURES[:tokens] = 'lib/skylab/css-convert/css-parser/tokens.flex'

  module Parameter end
  module Parameter::Definer end
  module Parameter::Definer::ModuleMethods
    def param name, meta
      parameters.fetch!(name).merge!(meta)
    end
    def parameters &block
      if block_given?
        (@parametersf ||= nil) and fail('no')
        (@parameters ||= nil) and fail('no')
        @parametersf = block
        return
      end
      @parameters ||= begin
        p = Parameter::Set.new(self)
        a = ancestors
        nil until ::Object == (m = a.pop)
        self == a[0] and a.shift
        mods = [] ; klass = nil
        a.each do |mod|
          mod.respond_to?(:parameters) or next
          if Class === mod
            ! klass and mods.push(klass = mod)
          else
            ! (klass && klass.ancestors.include?(mod)) and mods.push(mod)
          end
        end
        if mods.any?
          mods.reverse.each { |mod| p.merge!(mod.parameters) }
        end
        if (@parametersf ||= nil)
          @parameters = p # ick
          instance_exec(&@parametersf)
          @parametersf = nil
        end
        p
      end
    end
  end

  class Parameter::Set < Struct.new(:list)
    attr_reader :host
    def [] name
      (idx = @hash[name]) ? list[idx] : nil
    end
    def initialize host
      super([])
      @hash = {}
      @host = host
    end
    def fetch! k
      unless idx = @hash[k]
        @hash[k] = idx = list.length
        list[idx] = Parameter::Definition.new(@host, k)
      end
      list[idx]
    end
    def merge! set
      set.list.each do |o|
        fetch!(o.name).merge!(o)
      end
      nil
    end
  end

  class Parameter::Definition < Hash
    extend Parameter::Definer::ModuleMethods
    def define_method name, &block
      host.send(:define_method, name, &block)
    end
    attr_reader :host
    def initialize host, name
      self[:name] = name
      @host = host
    end
    def label ; name end
    def merge! meta
      meta.each do |k, v| # note meta is either a arg hash or a self.class obj!
        :name == k and next
        self[k] == v and next
        self[k] = v # possibly let the below do some post processing?
        send("#{k}=", v)
      end
    end
    def name
      self[:name] # this line of code is the center of the universe
    end
    def param_reader
      name = self.name
      define_method(name) { self[name] }
    end
    def param_writer
      name = self.name
      define_method("#{name}=") { |v| self[name] =v }
    end
    # -- * --
    def accessor= _
      param_reader
      param_writer
    end
    def boolean= no=true
      name = self.name
      true == no and no = "not_#{name}"
      define_method("#{name}!") { self[name] = true }
      define_method("#{no}!") { self[name] = false }
      define_method("#{name}?") { self[name] }
      define_method("#{no}?") { ! self[name] }
      define_method("#{name}=") { |v| self[name] = v }
    end
    def default= v
      has_default!
      def self.default_value ; @defaultf.call end
      @defaultf = ->{v}
    end
    def enum= enum
      self[:enum] = enum
      param_reader
      name = self.name
      define_method("#{name}=") do |v|
        if (p = _formal_parameters[name]).enum.include?(v)
          self[name] = v
        else
          _client do
            error("#{v.inspect} is an invalid value for #{em p.label}.")
          end
        end
      end
    end
    def pathname= _
      name = self.name
      define_method("#{name}=") do |v|
        v and String === v and v = ::Pathname.new(v) # not sure
        self[name] = v
      end
      param_reader
    end
    def reader= _
      param_reader
    end
    # --- * ---
    param :enum, reader: true
    param :getter, accessor: true
    param :has_default, boolean: :does_not_have_default
    param :internal, boolean: :external
    param :required, boolean: true
  end

  module Parameter::Controller end

  module Parameter::Controller::InstanceMethods
    # and_ em error errors_count formal_parameters params s
    def defaults request
      fp = formal_parameters
      pks = request.keys ; dks = fp.list.select(&:has_default?).map(&:name)
      request.merge!  Hash[ (dks - pks).map { |k| [k, fp[k].default_value] } ]
      nil
    end
    def missing_required
      a = formal_parameters.list.select(&:required?).reduce([]) do |m, p|
        m << p if params[p.name].nil? ; m
      end.map { |o| em o.label }
      a.any? and error("missing the required parameter#{s a} #{and_ a}")
    end
    def prune_bad_keys request # internal defaults may exist hence ..
      notpar = intern = nil ; formal = formal_parameters
      request.keys.each do |k|
        ok = false
        if ! (param = formal[k]) then (notpar ||= []).push(k)
        elsif param.internal?    then (intern ||= []).push(param.label)
        else ok = true
        end
        ok or request.delete(k) # for aggregation of errors (non-atomic)
      end
      notpar and notpar.map! { |l| em l }
      intern and intern.map! { |l| em l }
      notpar and error("#{and_ notpar} #{s :is} not #{s :a}parameter#{s}")
      intern and error("#{and_ intern} #{s :is} #{s :an}internal parameter#{s}")
    end
    def set! request
      errors_count_before = errors_count
      prune_bad_keys(request = request ? request.dup : {})
      defaults request
      request.each do |k, v|
        if ! params.respond_to?(meth = "#{k}=")
          error("not writable: #{k}")
        else
          params.send(meth, v) # not atomic w/ all of above as es muss sein
        end
      end
      missing_required
      errors_count_before == errors_count
    end
  end

  module Request end
  class Request::Runtime < Struct.new(:build_io_adapter, :build_params)
    members.each do |builder|
      attr_writer(stem = /(?<=\Abuild_).*/.match(builder.to_s)[0].intern)
      ivar = "@#{stem}"
      define_method stem do
        instance_variable_defined?(ivar) ? instance_variable_get(ivar) :
          instance_variable_set(ivar, send(builder).call)
      end
    end
  end

  module SubClient end

  # params controller
  # implement: and_ em error errors formal_parameters params s
  module SubClient::InstanceMethods
    def emit(*a) ; io_adapter.emit(*a) end
    def error(s) ; emit(:error, s) ; false end
    def initialize(r) ; self.request_runtime = r end
    def io_adapter ; request_runtime.io_adapter end
    def params ; request_runtime.params end
    attr_accessor :request_runtime
    # --- * ---
    def em s ; io_adapter.em s end
    # --- * ---
    THE_ENGLISH_LANGUAGE = # @id: 6
      { a: ['a '], an: ['an '], is: ['is', 'are'], s:[nil, 's'] }
    def and_ a, last = ' and ', sep = ', '
      @_coun = ::Fixnum === a ? a : a.length
      (hsh = Hash.new(sep))[a.length - 1] = last
      [a.first, * (1..(a.length-1)).map { |i| [ hsh[i], a[i] ] }.flatten].join
    end
    def s count=nil, part=nil
      args = [count, part].compact
      part = ::Symbol === args.last ? args.pop : :s
      coun = 1 == args.length ? args.pop : @_coun
      @_coun = ::Fixnum === coun ? coun : coun.length # gigo
      THE_ENGLISH_LANGUAGE[part][1 == @_coun ? 0 : 1]
    end
  end

  module Client end

  module Client::InstanceMethods
    include SubClient::InstanceMethods
    def build_request_runtime
      request_runtime_class.new(
        ->{build_io_adapter}, ->{build_params} )
    end
    def initialize ; end # override parent-child type constructor from s.c.
    def request_runtime ; @request_runtime ||= build_request_runtime end
  end

  module IO end
  module IO::Adapter end
  module IO::Adapter::InstanceMethods
    def em s ; pen.em s end
  end

  module CLI end # new() hack defined below

  module CLI::InstanceMethods
    include Client::InstanceMethods
    def invoke argv
      @argv = argv
      (@queue ||= []).clear
      begin
        option_parser.parse! argv
      rescue ::OptionParser::InvalidOption => e
        return usage(e.message)
      end
      queue.empty? and enqueue!(default_action)
      last = nil
      until queue.empty?
        method = queue.shift and (last = send(method) or break)
      end
      last
    end
  protected
    attr_reader :argv
    def enqueue! method
      queue.push method
    end
    def help_string
      option_parser.to_s
    end
    def help
      emit(:help, help_string)
      true
    end
    def option_parser
      @option_parser ||= build_option_parser
    end
    def program_name
      (@program_name ||= nil) || File.basename($PROGRAM_NAME)
    end
    attr_writer :program_name
    attr_reader :queue
    def suppress_normal_output!
      @suppress_normal_output = true
      self
    end
    attr_reader :suppress_normal_output
    alias_method :suppress_normal_output?, :suppress_normal_output
    def usage msg # @todo here is the place to put invites
      emit(:usage, msg)
      emit(:help, "use #{em "#{program_name} -h"} for more help")
      nil # sic
    end
  end

  module API end
  module API::InstanceMethods
    include Client::InstanceMethods
    def invoke meth, params=nil
      API::Promise.new do
        response do
          if ! action_names.include?(meth)
            error("cannot #{meth}")
          elsif result = send(meth, *[params].compact)
            true == result or emit(:payload, result)
          end
        end
      end
    end
  protected
    def action_names # all public methods that we created
      _a = self.class.ancestors
      [].tap { |a| m = nil ; a << m until ::Object == (m = _a.shift) }.
        map { |m| m.public_instance_methods false }.flatten - [:invoke]
    end
    def response
      yield # caller must handle return value processing of client method
      if (io = request_runtime.io_adapter).errors.empty?
        io.payloads.length > 1 ? io.payloads : io.payloads.first # look
      else
        raise API::RuntimeError.new(io.errors.join('; '))
      end
    end
  end

  class API::Promise < ::BasicObject # thanks Ben Lavender
    NOT_SET = ::Object.new
    def initialize &b
      @block = b
      @result = NOT_SET
    end
    def method_missing *a, &b
      __result__.send(*a, &b)
    end
    def __result__
      NOT_SET == @result and @result = @block.call
      @result
    end
  end



  # -- abstraction barrier ? --

  IN_FILE = '<flexfile>'

  module My end
  module My::Parameter end
  class My::Parameter::Controller
    include Parameter::Controller::InstanceMethods
    include SubClient::InstanceMethods
    def errors_count ; request_runtime.errors_count end
    def formal_parameters
      params.class.parameters
    end
  end

  module My::Request end
  class My::Request::Runtime < Request::Runtime
    def builder
      @builder ||= My::TreetopBuilder.new(io_adapter.outstream)
    end
    def errors_count ; io_adapter.errors_count end
    def parameters
      @parameters ||= My::Parameter::Controller.new(self)
    end
    def translate_name flex_name
      flex_name # @todo prefixes, whatever
    end
  end

  module My::Headless end
  class My::Headless::Client
    def version
      emit(:payload, "#{program_name} version #{VERSION}")
    end
  protected
    def in_file ; IN_FILE end
    def parameters ; request_runtime.parameters end # *very* experimental!
    def request_runtime_class ; My::Request::Runtime end
  end

  module My::CLI end
  module My::CLI::Actions end
  module My::CLI::Actions::Translate end
  class My::CLI::Actions::Translate::Parameters < ::Hash
    extend Parameter::Definer::ModuleMethods
    param :case_insensitive, boolean: :case_sensitive, default: true
    param :clear_generated_files, boolean: :dont_clear_generated_files
    param :filesystem_parser_enabled, boolean: true
    param :filesystem_parser_dir, pathname: true
    param :result_state, internal: true, enum: [:exists, :filesystem_touched,
            :modified, :not_found, :parse_failure, :translated,
            :translate_failure, :showed_sexp]
    param :show_sexp, boolean: :dont_show_sexp, default: false
    param :suppress_normal_output_after_filesystem_parser, boolean: true
    param :verbose, boolean: true, default: true
    # -- * --
    # the /^[a-z]/ namespace is off limits to us for method names here
    def _client &block
      @_client.instance_eval(&block)
    end
    def _formal_parameters
      self.class.parameters
    end
    def initialize client
      @_client = client
    end
  end

  module My::API end

  def API.invoke method, params=nil # look
    My::API::Client.new.invoke(method, params)
  end

  module My::API::Actions end
  module My::API::Actions::Translate end
  class My::API::Actions::Translate::Parameters <
    My::CLI::Actions::Translate::Parameters

    param :force, boolean: true, default: true
    param :flexfile, pathname: true, required: true
    param :outfile, pathname: true, required: true
    param :verb, accessor: true, internal: true
  end

  AUTOGENERATED_LINE =
    "# Autogenerated by flex2treetop on {{now}}. Edits may be lost."
  AUTOGENERATED_RE   = /autogenerated by flex2treetop/i

  class My::API::Client < My::Headless::Client
    include API::InstanceMethods
    def translate request=nil
      parameters.set!(request) or return
      resolve_io or return params.result_state
      begin
        params.result_state = My::Translation.new(request_runtime).invoke
      ensure
        io_adapter.outstream.closed? or io_adapter.outstream.close
        io_adapter.instream.closed? or io_adapter.instream.close
      end
      params.result_state
    end
  protected
    def build_io_adapter
      My::API::IO::Adapter.new
    end
    def build_params
      My::API::Actions::Translate::Parameters.new(self)
    end
    def program_name ; "Flex to Treetop" end
    def resolve_io
      if ! (p = params).flexfile.exist?
        error("file not found: #{p.flexfile}")
        p.result_state = :not_found
      elsif p.outfile.exist?
        if p.force?
          s = nil ; p.outfile.open('r') { |h| s = h.gets }
          if AUTOGENERATED_RE =~ s
            p.verb = 'overwritinag'
          elsif p.outfile.stat.size.zero?
            emit(:info, "(overwriting empty file: #{p.outfile})")
            p.verb = 'overwriting'
          else
            error("won't overwrite, does not appear generated: #{p.outfile}")
            p.result_state = :modified
          end
        else
          emit(:info, "exists, won't overwrite without force: #{p.outfile}")
          p.result_state = :exists
        end
      else
        p.verb = 'creating'
      end
      if ! p.result_state
        io_adapter.instream = params.flexfile.open('r')
        io_adapter.outstream = params.outfile.open('w')
      end
      ! p.result_state
    end
  end

  module My::API::IO end
  class My::API::IO::Pen
    def em s ; "\"#{s}\"" end
  end
  class My::API::IO::Adapter < ::Struct.new(
    :payloads, :errors, :info_stream, :instream, :outstream, :pen
  )
    include IO::Adapter::InstanceMethods
    def initialize
      super([], [], $stderr, nil, nil, My::API::IO::Pen.new)
    end
    def emit type, mixed
      case type
      when :payload ; payloads << mixed
      when :error   ; errors   << mixed
                    ; info_stream.puts("(api #{type} preview): #{mixed}")
      else          ; info_stream.puts("(api #{type}): #{mixed}")
      end
      nil # undefined
    end
    def errors_count ; errors.length end
  end

  class API::RuntimeError < ::RuntimeError ; end # reveal

  def CLI.new ; My::CLI::Client.new end # reveal

  class My::CLI::Client < My::Headless::Client
    include CLI::InstanceMethods
    def build_option_parser
      o = ::OptionParser.new
      o.banner = "Usage: #{program_name} [options] #{in_file}"

      o.on('-g=<grammar>', '--grammar=<grammar>',
        "nest treetop output in this grammar declaration",
        "(e.g. \"Mod1::Mod2::Grammar\")."
      ) { |g| params[:grammar] = g }

      o.on('-s', '--sexp',
        "show sexp of parsed flex file",
        "suppress normal output. (devel)"
      ) { params.show_sexp! } # sic. suppression is with logic

      o.on('--flex-tt',
       'write the flex treetop grammar to stdout.',
       "suppressed normal output. (devel)"
      ) { suppress_normal_output!.enqueue!(:grammar) }

      o.on('-t[=<dir>]', '--tempdir[=<dir>]',
        '[write, ]read flex treetop grammar',
        '[from ,] to the filesystem as opposed to in memory. (devel)',
        'multiple times will supress normal output.',
        'use --clear (below) to force a rewrite of the file(s).'
      ) do |v|
        v and params.filesystem_parser_dir = v
        if params.filesystem_parser_enabled?
          params.suppress_normal_output_after_filesystem_parser!
          suppress_normal_output! # a small smell is here
        else
          params.filesystem_parser_enabled!
        end
      end

      o.on('-c', '--clear',
        'if used in conjuction with --tmpdir,',
        'clear any existing parser files first (devel).'
      ) { params.clear_generated_files! }

      o.on('-h', '--help', 'show this message') do
        suppress_normal_output!.enqueue!(:help)
      end
      o.on('-v', '--version', 'show version') do
        suppress_normal_output!.enqueue!(:version)
      end
      o
    end

    def build_io_adapter
      My::CLI::IO::Adapter.new($stdin, $stdout, $stderr, My::CLI::IO::Pen.new)
    end

    def build_params
      My::CLI::Actions::Translate::Parameters.new(self)
    end

    def default_action ; :translate end

    def grammar
      emit(:payload, TREETOP_GRAMMAR)
    end

    def translate
      unless suppress_normal_output?
        resolve_instream or return
      end
      My::Translation.new(request_runtime).invoke
    end

    # #abstraction-candidate
    def resolve_instream
      stdin = io_adapter.instream.tty? ? :tty : :stdin
      no_argv = argv.empty? ? :no_argv : :argv
      opcode =
      case [stdin, no_argv]
      when [:tty, :argv], [:tty, :no_argv] ; :argv
      when [:stdin, :argv]                 ; :ambiguous
      when [:stdin, :no_argv]              ; :stdin
      end
      case opcode
      when :ambiguous
        usage("cannot resolve ambiguous instream modality paradigms -- " <<
          "both STDIN and #{in_file} appear to be present.")
        nil
      when :stdin ; true # noop. io_adapter.instream is $stdin or the like
      when :argv
        in_path = case argv.length
        when 0 ; suppress_normal_output? ?
                   info("No #{in_file} argument present. Done.") :
                   usage("expecting: #{in_file}")
                 nil
        when 1 ; argv.shift
        else   ; usage "expecting: #{in_file} had: (#{argv.join(' ')})"
        end
        in_path and begin
          in_path = ::Pathname.new(in_path)
          if ! in_path.exist? then usage("#{in_file} not found: #{in_path}")
          elsif in_path.directory? then usage("#{in_file} is dir: #{in_path}")
          else io_adapter.instream = in_path.open('r') # closed at ''spot 1''
          end
        end
      end
    end
  end

  module My::CLI::IO end
  class My::CLI::IO::Pen
    def em s ; stylize(s, :strong, :green) end
    MAP = { strong: 1, red: 31, green: 32 }
    def stylize str, *styles
      "\e[#{styles.map{ |s| MAP[s] }.compact.join(';')}m#{str}\e[0m"
    end
  end

  class My::CLI::IO::Adapter <
    ::Struct.new(:instream, :outstream, :errstream, :pen)

    include IO::Adapter::InstanceMethods
    def emit type, msg
      send( :payload == type ? :outstream : :errstream ).puts msg
      nil # undefined
    end
  end

  class My::Translation
    include SubClient::InstanceMethods
    def instream ; io_adapter.instream end
    def invoke
      p = params
      p.verbose? and emit(:info, "#{p.verb} #{p.outfile} with #{p.flexfile}")
      p.filesystem_parser_enabled? and (use_filesystem or return)
      whole_file = instream.read
      instream.close # ''spot 1''
      io_adapter.outstream.puts autogenerated_line
      result = parser.parse(whole_file)
      if ! result
        error(parser.failure_reason || "Got nil from parse without reason")
        :parse_failure
      elsif p.show_sexp?
        require 'pp'
        ::PP.pp(result.sexp, io_adapter.errstream)
        :showed_sexp
      elsif result.sexp.translate(request_runtime)
        :translated
      else
        :translate_failure
      end
    end
  protected
    def autogenerated_line
      AUTOGENERATED_LINE.gsub(/\{\{((?:(?!\}\}).)+)\}\}/) do
        case $1
        when 'now' ; Time.now.strftime('%Y-%m-%d %I:%M:%S%P %Z')
        end
      end
    end
    def autogenerated_re ; AUTOGENERATED_RE end
    def clear_generated_files
      [f2tt_tt, f2tt_rb].each do |path|
        path.exist? and file_utils.rm(path.to_s, verbose: true)
      end
    end
    attr_reader :f2tt_tt, :f2tt_rb
    def file_utils # future-proofed for hacking
      @file_utils ||= begin
        require 'fileutils'
        extend ::FileUtils
        @fileutils_output = request_runtime.io_adapter.errstream
        @fileutils_label = "(futils:) "
        singleton_class.send(:public, :rm)
        ->{ self }
      end
      @file_utils.call
    end
    def parser
      @parser ||= parser_class.new
    end
    def parser_class
      @parser_class ||= begin
        unless defined?(FlexFileParser)
          ::Treetop.load_from_string TREETOP_GRAMMAR
        end
        c = ::Class.new FlexFileParser
        c.class_eval(&PARSER_EXTLIB)
        c
      end
    end
    def recompile
      a = []
      f2tt_tt.exist? or begin
        bytes = write_grammar_file
        a.push "wrote #{f2tt_tt} (#{bytes} bytes)."
      end
      emit(:info, a.push("writing #{f2tt_rb}.").join(' '))
      ::Treetop::Compiler::GrammarCompiler.
        new.compile(f2tt_tt.to_s, f2tt_rb.to_s)
    end
    def use_filesystem
      (p = params).filesystem_parser_dir ||= (require 'tmpdir' ; ::Dir.tmpdir)
      dirname = p.filesystem_parser_dir # (necessary in its own line)
      dirname.directory? or return error("not a directory: #{dirname}")
      @f2tt_tt = dirname.join('flex-to-treetop.treetop')
      @f2tt_rb = dirname.join('flex-to-treetop.rb')
      p.clear_generated_files? and clear_generated_files
      f2tt_rb.exist? ? emit(:info, "using: #{f2tt_rb}") : recompile
      rb = f2tt_rb.absolute? ? f2tt_rb : f2tt_rb.expand_path
      require rb.to_s.sub(/\.rb\z/, '') # "bare()" externally
      if p.suppress_normal_output_after_filesystem_parser?
        emit(:info, "touched files. nothing more to do.")
        p.result_state = :filesystem_parsers_touched
        false # leave
      else
        true # stay
      end
    end
    def write_grammar_file
      bytes = nil
      f2tt_tt.open('w+') { |fh| bytes = fh.write(TREETOP_GRAMMAR) }
      bytes
    end
  end
end

class Skylab::FlexToTreetop::Sexpesque < Array # class Sexpesque
  class << self
    def add_hook(whenn, &what)
      @hooks ||= Hash.new{ |h,k| h[k] = [] }
      @hooks[whenn].push(what)
    end
    def guess_node_name
      m = to_s.match(/([^:]+)Sexp$/) and
        m[1].gsub(/([a-z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern
    end
    def hooks_for(whenn)
      instance_variable_defined?('@hooks') ? @hooks[whenn] : []
    end
    def from_syntax_node name, node
      new(name, node).extend SyntaxNodeHaver
    end
    def traditional name, *rest
      new(name, *rest)
    end
    def hashy name, hash
      new(name, hash).extend Hashy
    end
    attr_writer :node_name
    def node_name *a
      a.any? ? (@node_name = a.first) :
      (instance_variable_defined?('@node_name') ? @node_name :
        (@node_name = guess_node_name))
    end
    def list list
      traditional(node_name, *list)
    end
    def terminal!
      add_hook(:post_init){ |me| me.stringify_terminal_syntax_node! }
    end
  end
  def initialize name, *rest
    super [name, *rest]
    self.class.hooks_for(:post_init).each{ |h| h.call(self) }
  end
  def stringify_terminal_syntax_node!
    self[1] = self[1].text_value
    @syntax_node = nil
    class << self
      alias_method :my_text_value, :last
    end
  end
  module SyntaxNodeHaver
    def syntax_node
      instance_variable_defined?('@syntax_node') ? @syntax_node : last
    end
  end
  module Hashy
    class << self
      def extended obj
        class << obj
          alias_method :children, :last
        end
      end
    end
  end
end

module Skylab::FlexToTreetop::CommonNodey
  Sexpesque = ::Skylab::FlexToTreetop::Sexpesque
  def at(str); ats(str).first end
  def ats path
    path = at_compile(path) if path.kind_of?(String)
    here = path.first
    cx = (here == '*') ? elements : (elements[here] ? [elements[here]] : [])
    if path.size > 1 && cx.any?
      child_path = path[1..-1]
      cx = cx.map do |c|
        c.extend(::Skylab::FlexToTreetop::CommonNodey) unless
          c.respond_to?(:ats)
        c.ats(child_path)
      end.flatten
    end
    cx
  end
  def at_compile str
    res = []
    s = ::StringScanner.new(str)
    begin
      if s.scan(/\*/)
        res.push '*'
      elsif s.scan(/\[/)
        d = s.scan(/\d+/) or fail("expecting digit had #{s.rest.inspect}")
        s.scan(/\]/) or fail("expecting ']' had #{s.rest.inspect}")
        res.push d.to_i
      else
        fail("expecting '*' or '[' near #{s.rest.inspect}")
      end
    end until s.eos?
    res
  end
  def sexp_at str
    # (n = at(str)) ? n.sexp : nil
    n = at(str) or return nil
    n.respond_to?(:sexp) and return n.sexp
    n.text_value == '' and return nil
    fail("where is sexp for n")
  end
  def sexps_at str
    ats(str).map(&:sexp)
  end
  def composite_sexp my_name, *children
    with_names = {}
    children.each do |name|
      got = send(name)
      sexp =
        if got.respond_to?(:sexp)
          got.sexp
        else
          fail('why does "got" have no sexp')
        end
      with_names[name] = sexp
    end
    if my_name.kind_of? Class
      my_name.hashy(my_name.node_name, with_names)
    else
      Sexpesque.hashy(my_name, with_names)
    end
  end
  def list_sexp *foos
    foos.compact!
    foos # yeah, that's all this does
  end
  def auto_sexp
    if respond_to?(:sexp_class)
      sexp_class.from_syntax_node(sexp_class.node_name, self)
    elsif ! elements.nil? && elements.index{ |n| n.respond_to?(:sexp) }
      cx = elements.map{ |n| n.respond_to?(:sexp) ? n.sexp : n.text_value }
      ::Skylab::FlexToTreetop::AutoSexp.traditional(guess_node_name, *cx)
    else
      ::Skylab::FlexToTreetop::AutoSexp.traditional(guess_node_name, text_value)
    end
  end
  def guess_node_name
    m = singleton_class.ancestors.first.to_s.match(/([^:0-9]+)\d+$/)
    if m
      m[1].gsub(/([a-z])([A-Z])/){ "#{$1}_#{$2}" }.downcase.intern
    else
      fail("what happen")
    end
  end
  def singleton_class
    @sc ||= class << self; self end
  end
end

module Skylab::FlexToTreetop
  class CommonNode < ::Treetop::Runtime::SyntaxNode
    include CommonNodey
  end
  module AutoNodey
    include CommonNodey
    def sexp; auto_sexp end
  end
  class AutoNode < CommonNode
    include AutoNodey
  end
end

module Skylab::FlexToTreetop
  module RuleWriter
  end
  class RuleWriter::Rule < Struct.new(
    :request_runtime, :rule_name, :pattern_like)

    def builder                   ; request_runtime.builder end
    def translate_name(*a)        ; request_runtime.translate_name(*a) end
    def write
      builder.rule_declaration(translate_name(rule_name)) do
        builder.write "".indent(builder.level)
        pattern_like.translate request_runtime
        builder.newline
      end
    end
  end
  module RuleWriter::InstanceMethods
    def write_rule request_runtime
      yield( build = RuleWriter::Rule.new(request_runtime) )
      build.write
    end
  end
  class FileSexp < Sexpesque # :file
    def translate ctx
      nest = [lambda {
        if children[:definitions].any?
          ctx.builder << "# from flex name definitions"
          children[:definitions].each{ |c| c.translate(ctx) }
        end
        if children[:rules].any?
          ctx.builder << "# flex rules"
          children[:rules].each{ |c| c.translate(ctx) }
        end
      }]
      if ctx.params.key?(:grammar)
        parts = ctx.params[:grammar].split('::')
        gname = parts.pop
        nest.push lambda{
          ctx.builder.grammar_declaration(gname, & nest.pop)
        }
        while mod = parts.pop
          nest.push lambda{
            mymod = mod
            lambda {
              ctx.builder.module_declaration(mymod, & nest.pop)
            }
          }.call
        end
      end
      nest.pop.call
    end
  end
  class StartDeclarationSexp < Sexpesque # :start_declaration
    def translate ctx
      case children[:declaration_value]
      when 'case-insensitive' ; ctx.params.case_insensitive!
      else
        ctx.builder <<
          "# declaration ignored: #{children[:declaration_value].inspect}"
      end
    end
  end
  class ExplicitRangeSexp < Sexpesque # :explicit_range
    class << self
      def bounded min, max
        min == '0' ? new('..', max) : new(min, '..', max)
      end
      def unbounded min
        new min, '..'
      end
      def exactly int
        new int
      end
    end
    def initialize *parts
      @parts = parts
    end
    def translate ctx
      ctx.builder.write " #{@parts.join('')}"
    end
  end
  class NameDefinitionSexp < Sexpesque # :name_definition
    include RuleWriter::InstanceMethods
    def translate ctx
      write_rule(ctx) do |m|
        m.rule_name = children[:name_definition_name]
        m.pattern_like = children[:name_definition_definition]
      end
    end
  end
  class RuleSexp < Sexpesque # :rule
    include RuleWriter::InstanceMethods

    # this is pure hacksville to deduce meaning from actions as they are
    # usually expressed in the w3c specs with flex files -- which is always
    # just to return the constant corresponding to the token
    def translate ctx
      action_string = children[:action].my_text_value
      /\A\{(.+)\}\Z/ =~ action_string and action_string = $1
      if md = /\Areturn ([a-zA-Z_]+);\Z/.match(action_string)
        from_constant(ctx, md[1])
      elsif md = %r{\A/\*([a-zA-Z0-9 ]+)\*/\Z}.match(action_string)
        from_constant(ctx, md[1].gsub(' ','_')) # extreme hack!
      else
        ctx.io_adapter.emit(:info,
          "notice: Can't deduce a treetop rule name from: " <<
          "#{action_string.inspect}  Skipping."
        )
        nil
      end
    end
    def from_constant ctx, const
      write_rule(ctx) do |m|
        m.rule_name = const
        m.pattern_like = children[:pattern]
      end
    end
  end
  class PatternChoiceSexp < Sexpesque # :pattern_choice
    def translate ctx
      (1..(last = size-1)).each do |idx|
        self[idx].translate(ctx)
        ctx.builder.write(' / ') if idx != last
      end
    end
  end
  class PatternSequenceSexp < Sexpesque # :pattern_sequence
    def translate ctx
      (1..(last = size-1)).each do |idx|
        self[idx].translate(ctx)
        ctx.builder.write(' ') if idx != last
      end
    end
  end
  class PatternPartSexp < Sexpesque # :pattern_part
    def translate ctx
      self[1].translate(ctx)
      self[2] and self[2][:range].translate(ctx)
    end
  end
  class UseDefinitionSexp < Sexpesque # :use_definition
    def translate ctx
      ctx.builder.write ctx.translate_name(self[1])
    end
  end
  class LiteralCharsSexp < Sexpesque # :literal_chars
    terminal!
    def translate ctx
      ctx.builder.write self[1].inspect # careful! put lit chars in dbl "'s
    end
  end
  class CharClassSexp < Sexpesque # :char_class
    terminal! # no guarantee this will stay this way!
    def translate ctx
      ctx.builder.write( ctx.params.case_insensitive? ?
        case_insensitive_hack(my_text_value) : my_text_value )
    end
    def case_insensitive_hack txt
      s = StringScanner.new(txt)
      out = ''
      while found = s.scan_until(/[a-z]-[a-z]|[A-Z]-[A-Z]/)
        repl = (/[a-z]/ =~ s.matched) ? s.matched.upcase : s.matched.downcase
        s.scan(/#{repl}/) # whether or not it's there scan over it. careful!
        out.concat("#{found}#{repl}")
      end
      "#{out}#{s.rest}"
    end
  end
  class HexSexp < Sexpesque # :hex
    terminal!
    def translate ctx
      ctx.builder.write "OHAI_HEX_SEXP"
    end
  end
  class OctalSexp < Sexpesque # :octal
    terminal!
    def translate ctx
      ctx.builder.write "OHAI_OCTAL_SEXP"
    end
  end
  class AsciiNullSexp < Sexpesque # :ascii_null
    terminal!
    def translate ctx
      ctx.builder.write "OHAI_NULL_SEXP"
    end
  end
  class BackslashOtherSexp < Sexpesque # :backslash_other
    terminal!
    def translate ctx
      # byte per byte output the thing exactly as it is, but wrapped in quotes
      ctx.builder.write "\"#{my_text_value}\""
    end
  end
  class ActionSexp < Sexpesque # :action
    terminal! # these are hacked, not used conventionally
  end
  class AutoSexp < Sexpesque
    def translate ctx
      self[1..size-1].each do |c|
        if c.respond_to?(:translate)
          c.translate(ctx)
        else
          ctx.builder.write c
        end
      end
    end
  end
end

module Skylab::FlexToTreetop
  class ProgressiveOutputAdapter < ::Struct.new(:out)
    def <<(*a)
      out.write(*a)
      self
    end
  end
  class My::TreetopBuilder < ::Treetop::Compiler::RubyBuilder
    def initialize outstream
      super() # nathan sobo reasonably sets @ruby to a ::String here, (@hack?)
      @ruby = ProgressiveOutputAdapter.new(outstream) # but we need this
    end
    def rule_declaration name, &block
      self << "rule #{name}"
      indented(&block)
      self << "end"
    end
    def grammar_declaration(name, &block)
      self << "grammar #{name}"
      indented(&block)
      self << "end"
    end
    def write *a
      @ruby.<<(*a)
    end
  end
end


Skylab::FlexToTreetop::PARSER_EXTLIB = lambda do |_|
  # CompiledParser#failure_reason overridden for less context
  def failure_reason
    return nil unless (tf = terminal_failures) && tf.size > 0
    "Expected " +
      ( tf.size == 1 ?
        tf[0].expected_string.inspect :
        "one of #{tf.map{|f| f.expected_string.inspect}.uniq*', '}"
      ) + " at line #{failure_line}, column #{failure_column} " +
      "(byte #{failure_index+1}) after#{my_input_excerpt}"
  end

  def num_lines_ctx; 4 end

  def my_input_excerpt
    num = num_lines_ctx
    slicey = input[index...failure_index]
    all_lines = slicey.split("\n", -1)
    lines = all_lines.slice(-1 * [all_lines.size, num].min, all_lines.size)
    nums = failure_line.downto(
      [1, failure_line - num + 1].max).to_a.reverse
    w = nums.last.to_s.size # greatest line no as string, how wide?
    ":\n" + nums.zip(lines).map do |no, line|
      ("%#{w}i" % no) + ": #{line}"
    end.join("\n")
  end
end

Skylab::FlexToTreetop::TREETOP_GRAMMAR = <<'GRAMMAR'
# The 'pattern' rule below is a subset of the grammar grammar described at
#   http://flex.sourceforge.net/manual/Patterns.html.
#   Note that not all constructs are supported, only those necessary
#   to parse the target flex input files for this project.

module Skylab
module FlexToTreetop
grammar FlexFile
  rule file
    definitions spacey* '%%' spacey* rules spacey*  <CommonNode>
    { def sexp; composite_sexp FileSexp, :definitions, :rules end }
  end
  rule definitions
    spacey*  ( definition_declaration (decl_sep definition_declaration)*  )?
    <CommonNode> {
      def sexp
        list_sexp(sexp_at('[1][0]'), * sexps_at('[1][1]*[1]'))
      end
    }
  end
  rule definition_declaration
    name_definition / start_declaration
  end
  rule name_definition
    name_definition_name [ \t]+ name_definition_definition
    <CommonNode> {
      def sexp
        composite_sexp(
          NameDefinitionSexp, :name_definition_name,
            :name_definition_definition
        )
      end
    }
  end
  rule name_definition_name
    [A-Za-z_] [-a-zA-Z0-9_]* {
      def sexp
        text_value
      end
    }
  end
  rule name_definition_definition
    pattern
  end
  rule start_declaration
    '%' 'option' [ \t]+ 'case-insensitive'
     <CommonNode> {
      def sexp
        StartDeclarationSexp.hashy( :start_declaration,
          :declaration_type  => 'option',
          :declaration_value => 'case-insensitive'
        )
      end
    }
  end
  rule rules
    rool (decl_sep rool)* <CommonNode> {
      def sexp
        list_sexp(sexp_at('[0]'), *sexps_at('[1]*[1]'))
      end
    }
  end
  rule rool
    pattern [ \t]+ action <CommonNode> {
      def sexp
        composite_sexp(RuleSexp, :pattern, :action)
      end
    }
  end
  rule pattern
    pattern_part pattern_part* ( '|' pattern )* <CommonNode> {
      def sexp
        seq = list_sexp(sexp_at('[0]'), * sexps_at('[1]*'))
        choice = sexps_at('[2]*[1]')
        seq_or_pat = seq.size == 1 ? seq.first : PatternSequenceSexp.list(seq)
        if choice.any?
          PatternChoiceSexp.list( [seq_or_pat] + choice )
        else
          seq_or_pat
        end
      end
    }
  end
  rule pattern_part
    ( character_class / string / use_definition / backslashes /
        dot / literal_chars / parenthesized_group ) range?
    <CommonNode> {
      def sexp
        els = [sexp_at('[0]')]
        range = sexp_at('[1]') and els.push(:range => range)
        PatternPartSexp.traditional(:pattern_part, *els)
      end
    }
  end
  rule parenthesized_group
    '(' pattern ')' <AutoNode> { }
  end
  rule character_class
    '[' ( '\]' / !']' . )* ']' <AutoNode> {
      def sexp_class; CharClassSexp end
    }
  end
  rule string
    '"' (!'"' . / '\"')* '"' <AutoNode> { }
  end
  rule use_definition
    '{' name_definition_name '}' <CommonNode> {
      def sexp
        UseDefinitionSexp.traditional(:use_definition, elements[1].text_value)
      end
    }
  end
  rule backslashes
    hex / octal / null / backslash_other
  end
  rule hex
    '\\x' [0-9A-Za-z]+ <AutoNode> { def sexp_class; HexSexp end }
  end
  rule octal
    '\\' [1-9] [0-9]* <AutoNode> { def sexp_class; OctalSexp end }
  end
  rule null
    '\\0' <AutoNode> { def sexp_class; AsciiNullSexp end }
  end
  rule backslash_other
    '\\' [^ \t\n\r\f] <AutoNode> { def sexp_class; BackslashOtherSexp end }
  end
  rule action
    [^\n]+ <AutoNode> { def sexp_class; ActionSexp end }
  end
  rule dot
    '.' <AutoNode> { }
  end
  rule literal_chars
    [^\\|/\[\](){} \t\n\r\f'"]+ <AutoNode> {def sexp_class; LiteralCharsSexp end }
  end
  rule range
    shorthand_range / explicit_range
  end
  rule shorthand_range
    ( '*' / '+' / '?' ) <AutoNodey> { }
  end
  rule explicit_range
    '{' [0-9]+ ( ',' [0-9]* )? '}' <CommonNode> {
      def sexp
        if elements[2].elements.nil?
          ExplicitRangeSexp.exactly(elements[1].text_value)
        elsif "," == elements[2].text_value
          ExplicitRangeSexp.unbounded(elements[1].text_value)
        else
          ExplicitRangeSexp.bounded(elements[1].text_value,
            elements[2].elements[1].text_value
          )
        end
      end
    }
  end
  rule comment
    '/*' ( [^*] / '*' !'/' )* '*/' <AutoNode> {
      def sexp_class; CommentSexp end
    }
  end
  rule spacey
    comment / [ \t\n\f\r]
  end
  rule decl_sep
    ( [ \t] / comment )* newline spacey*
  end
  # http://en.wikipedia.org/wiki/Newline (near OSX)
  rule newline
    "\n" / "\r\n"
  end
end
end
end
GRAMMAR

__FILE__ == $PROGRAM_NAME and Skylab::FlexToTreetop::CLI.new.invoke(ARGV)
