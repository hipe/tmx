#!/usr/bin/env ruby
#

require 'fileutils'
require 'optparse'
require 'json'
require 'open3'
require 'stringio'
require 'time'
require 'ruby-debug'


module TmxGit
  PUSH_THRESHOLD_SECONDS = 24 * 60 * 60
  ARROW_GLYPH = '- '

  module Colors
    extend self
    def bold str ; style str, :bright, :green end
    def hi   str ; style str, :green          end
    def ohno str ; style str, :red            end
    def yelo str ; style str, :yellow         end
    Styles = { :bright => 1, :red => 31, :yellow => 33, :green => 32, :cyan => 36 }
    Esc = "\e"  # "\u001b" ok in 1.9.2
    def style str, *styles
      nums = styles.map{ |o| o.kind_of?(Integer) ? o : Styles[o] }.compact
      "#{Esc}[#{nums.join(';')}m#{str}#{Esc}[0m"
    end
  end
  module TimeHelper
    PER = u = {}
    u[:minute] = 60 ; u[:hour] = 60 * u[:minute] ; u[:day] = 24 * u[:hour]
    u[:week] = 7 * u[:day] ; u[:year] = 52 * u[:week]
    UNITS = [:year, :week, :day, :hour, :minute]
    class << self
      def natural seconds
        sec_i = seconds.to_i
        use = any = nil
        UNITS.each do |u|
          if 0 < (any = sec_i / PER[u])
            use = u
            break
          end
        end
        use or return "#{seconds} seconds"
        ss = ["#{any} #{use}#{s any}"]
        if use != UNITS.last
          _rem = sec_i % PER[use]
          _use = UNITS[UNITS.index(use) + 1]
          if 0 < (_any = _rem / PER[_use])
            ss.push "#{_any} #{_use}#{s _any}"
          end
        end
        "about #{ss.join(' ')}"
      end
      def s int
        1 == int ? '' : 's'
      end
    end
  end
  module Open2
    def open2 cmd
      streams = {
        :out => { :buffer => StringIO.new, :stream => ui.out },
        :err => { :buffer => StringIO.new, :stream => ui.err }
      }
      Open3.popen3(cmd) do |sin, sout, serr|
        streams[:out][:in] = sout
        streams[:err][:in] = serr
        open = [:out, :err]
        loop do
          open.each_with_index do |sym, idx|
            o = streams[sym]
            if IO.select([o[:in]], nil, nil, 0.1) # yes this could instead do .. etc
              closed = false
              begin
                str = o[:in].readpartial(4096)
                o[:in].closed? and closed = true
                o[:stream].write(str)
                o[:buffer].write(str)
              rescue EOFError => e
                closed = true
              end
              if closed
                open[idx] = nil
                open.compact!
              end
            end
          end
          open.empty? and break
        end
      end
      streams[:out][:buffer].rewind
      streams[:err][:buffer].rewind
      [streams[:out][:buffer].read, streams[:err][:buffer].read]
    end
  end
end
module TmxGit
  DefaultUi = Struct.new(:out, :err).new($stdout, $stderr)
  module Push
    class InvalidRequestError < RuntimeError; end
    class Cli
      def run argv
        argv = argv.dup
        req = {}
        ui = DefaultUi
        op = OptionParser.new do |o|
          o.banner = "usage: #{File.basename $PROGRAM_NAME}"
          o.on('-n', '--dry-run', 'Dry run.') { req[:dry_run] = true }
          o.on('-H', '--host URL', "Remote git server to push to (e.g. \"git@mysite.org\") (required!)") do |x|
            req[:host] = x
          end
          o.on('--prune-attr ATTR', '(internal use!)') do |v|
            req[:_prune] ||= []
            req[:_prune].push v
          end
        end
        begin
          op.parse!(argv)
          req[:paths] = argv.empty? ? ['.'] : argv
        rescue OptionParser::ParseError => e
          ui.err.puts "#{e}"
          ui.err.puts "#{op}"
          return false
        end
        begin
          Api.new(ui, req).push
        rescue InvalidRequestError => e
          ui.err.puts "#{e}"
          ui.err.puts "#{op}"
          return false
        end
        true
      end
    end
    class Api
      include Colors
      def initialize *a
        @ui, @req = a
      end
      attr_reader :req, :ui
      def push
        init_manifest or return false
        cnt = 0
        reps = @manifest.repositories
        _info "looking at #{reps.length} repos to push.."
        reps.each do |repo|
          cnt += 1
          ui.err.puts "#{hi repo.id} (#{cnt}/#{reps.length}):"
          repo.push
        end
        _info "looked at or pushed #{cnt} repos."
      end
    protected
      def init_manifest
        dir = @req[:paths].first
        File.directory?(dir) or dir = File.dirname(dir)
        File.directory?(dir) or return _err("not a directory, can't make manifest: #{dir}")
        ok = nil
        begin
          @manifest =
          if File.exist?(p = File.join(dir, Manifest::BASENAME))
            Manifest.reconstitute p, ui, @req
          else
            Manifest.create p, ui, @req
          end
          ok = true
        rescue Manifest::RuntimeError => e
          _err e
          ok = false
        end
        ok
      end
      def _err msg
        ui.err.puts "#{me}: #{ohno('error:')} #{msg}"
        false
      end
      def _info msg
        ui.err.puts "#{hi me}: #{msg}"
      end
      def me
        'git push'
      end
    end
    class Manifest
      BASENAME = 'manifest.json.list'
      class RuntimeError < ::RuntimeError; end
      class << self
        def reconstitute path, ui, req
          man = new(:ui => ui, :req => req, :path => path)
          repositories = []
          File.open(path, 'r') do |fh|
            while line = fh.gets
              repo = Repo.new(:manifest => man)
              repo.req = req
              repo.update_attributes JSON.parse(line)
              repositories.push repo
            end
          end
          man.repositories = repositories
          man
        end
        def create path, ui, req
          man = new(:ui => ui, :req => req, :path => path)
          man._create
          man
        end
      end
      def initialize hash = {}
        hash = hash.dup
        u = hash.delete(:ui) and self.ui = u
        r = hash.delete(:req) and self.req = r
        hash.each { |k, v| send("#{k}=", v) }
      end
      attr_reader   :path
      attr_accessor :records
      attr_accessor :repositories
      attr_accessor :repos_dir
      attr_accessor :req
      attr_accessor :ui
      def _create
        repositories = Dir[File.join(repos_dir, '*.git')]
        repositories.empty? and _fail("No repositories ending in '*.git' found in #{repos_dir}!")
        self.repositories = repositories.map { |path| Repo.new(:path => path, :manifest => self) }
        write_new_file
        nil
      end
      def path= path
        @repos_dir ||= File.dirname(path)
        @path = path
      end
      def update id, json_string
        json_string.include?("\n") and
          _fail("Fow now this ghetto format can't take newlines in json strings: #{json_string}")
        str = "\"id\":#{id.to_json}"
        finder = /#{Regexp.escape(str)}/
        first_half_lines = []
        second_half_lines = []
        old_line = nil
        File.open(path, 'r') do |fh|
          while line = fh.gets and finder !~ line do
            first_half_lines.push line.strip
          end
          if finder =~ line
            old_line = line
          else
            _fail("line not found with regex: #{finder}")
          end
          while line = fh.gets do
            second_half_lines.push line.strip
          end
        end
        all_lines = first_half_lines + [json_string] + second_half_lines
        all_content = all_lines.join("\n")
        ret = nil
        File.open(path, 'w') { |fh| ret = fh.write(all_content) }
        _report_updated id, old_line, json_string
        ret
      end
      def _report_updated id, old_line, json_string
        old = JSON.parse(old_line)
        now = JSON.parse(json_string)
        l = old.keys - now.keys
        r = now.keys - old.keys
        c = old.keys & now.keys
        a = [
          ("(elements removed: (#{_derp old, l}))" if l.any?),
          ("(elements added: (#{_derp now, r})" if r.any?)
        ].compact
        if c.any?
          _c = c.select { |k| old[k] != now[k] }
          if _c.any?
            s = _c.map { |k| "#{k.inspect} changed from #{old[k].inspect} to #{now[k].inspect}" }
            a.push "(#{s.join(', ')})"
          end
        end
        a.empty? and a.push("(no change)")
        _info "updated #{id} #{a.join(' ')}."
        nil
      end
      def _derp h, ks
        ks.map{ |k| "#{k.inspect} : #{h[k].inspect}" }.join(', ')
      end
      def write_new_file
        if File.exist?(path)
          _fail("won't clobber existing file: #{path}")
        end
        lines = []
        safety_check = {}
        repositories.each do |repo|
          if safety_check.key?(repo.id)
            _fail("multiple keys found: #{repo.id}")
          else
            safety_check[repo.id] = true
          end
          lines.push repo.to_json
        end
        bytes = 0
        File.open(path, 'w') do |fh|
          lines.each do |line|
            bytes += line.size
            fh.puts line
          end
        end
        _info "Wrote #{path} (#{bytes} bytes)"
        true
      end
      def _fail msg
        raise self.class::RuntimeError.new(msg)
      end
      def _info msg
        ui.err.puts "manifest #{msg}"
      end
    end
    class Repo
      include Colors, Open2
      ATTRS = {
        :id =>             { :stored => true }, # KEEP FIRST
        :branches =>       { :stored => true },
        :last_push_attempt_at => { :stored => true },
        :last_push_attempt_succeeded => { :stored => true },
        :path =>           { :stored => false },
        :skip =>           { :stored => true }
      }
      def initialize hash
        update_attributes hash
      end
      attr_accessor :branches
      attr_reader :id
      attr_reader :last_push_attempt_at
      attr_accessor :last_push_attempt_succeeded
      attr_reader :path
      attr_accessor :req
      attr_accessor :skip
      def update_attributes hash
        hash = hash.dup
        manifest = hash.delete(:manifest)
        manifest and self.manifest = manifest
        pruned = []
        hash.each do |k, v|
          if ATTRS.key?(k.intern)
            send("#{k}=", v)
          elsif req && req[:_prune] && req[:_prune].include?(k.to_s)
            pruned.push k
          else
            _fail("invalid attribute name: #{k.inspect} (you could --prune-attr it if you are careful!)")
          end
        end
        if pruned.any?
          _info "pruned: (#{pruned.join(', ')}) from #{id}"
          journal
        end
        true
      end
      def path= path
        @id = File.basename(path)
        @path = path
      end
      def id= id
        if manifest?
          @path = File.join(manifest.repos_dir, id)
        end
        @id = id
      end
      def last_push_attempt_at= mixed_time
        case mixed_time
        when String
          t = Time.parse(mixed_time) # will raise arg. error on bad parse
          @last_push_attempt_at = t
        when Time
          @last_push_attempt_at = mixed_time
        else
          raise ArgumentError.new("need string here")
        end
        mixed_time
      end
      def to_json
        hash = {}
        ATTRS.each do |k, v|
          v[:stored] or next
          unless (v = self.send(k)).nil?
            hash[k] = v
          end
        end
        hash.to_json
      end
      def push
        resp = { :push => false }
        if skip
          _info "Skipping (\"skip\":true)."
          resp[:push] = false
        elsif last_push_attempt_at.nil?
          _info "No record of ever having pushed, pushing."
          resp[:push] = true
        elsif (t = Time.now - last_push_attempt_at) > PUSH_THRESHOLD_SECONDS
          _info "Pushed #{_time t} ago.  Pushing again."
          resp[:push] = true
        elsif last_push_attempt_succeeded
          _info "Successfully pushed #{_time t} ago, skipping"
        elsif req[:retry]
          _info "Failed #{_time t} ago, retrying."
          resp[:push] = true
        else
          _info "Failed #{_time t} ago, skipping (\"retry\":false)."
        end
        resp[:push] and _push
        resp
      end
      def _push
        (host = req[:host]) or _invalid("can't push without a host")
        url = "#{req[:host]}:#{id}"
        push_branches = _push_branches or return false
        push_branches.each { |b| _push_branch b, url }
      end
      def _push_branch push_branch, url
        cmd = "cd #{path} ; git push #{url} #{push_branch}"
        _info cmd
        if req[:dry_run]
          _info "(dry run, skipped)"
          # journal
        else
          out, err = open2(cmd)
          self.last_push_attempt_at = Time.now
          if "" != out
            debugger; 1==1
          end
          if 0 == err.index(url)
            self.last_push_attempt_succeeded = true
            journal
          elsif 0 == err.index("Everything up-to-date")
            self.last_push_attempt_succeeded = true
            journal
          else
            self.last_push_attempt_succeeded = false
          end
        end
      end
      MASTER = ['master']
      def _push_branches
        req[:branch] and return [req[:branch]]
        @branches.kind_of?(Array) and return @branches
        list = `cd #{path} ; git branch`.strip.split("\n")
        list.map! { |s| s.gsub(/^\* /, '') }
        '*' == @branches and return list
        MASTER == list and return list
        if list.empty?
          _info "#{yelo 'notice'}: No branches!  Skipping."
          false
        else
          _info "#{yelo 'notice'}: please indicate branch to sync among: (#{list.join(', ')}).  Skipping."
          false
        end
      end
      def _info msg
        ui.err.puts "  #{ARROW_GLYPH}#{msg}"
      end
      def _time t
        TimeHelper.natural t
      end
      def journal &block
        manifest? or _fail("cannot journal a block without a manifest defined.")
        block and instance_eval(&block)
        manifest.update id, to_json
      end
      def manifest= manifest
        class << self; self end.send(:define_method, :manifest) { manifest }
        manifest
      end
      def manifest?
        respond_to?(:manifest)
      end
      def ui
        manifest.ui
      end
      def req
        manifest.req
      end
      def _fail msg
        raise Manifest::RuntimeError.new(msg)
      end
      def _invalid msg
        raise Push::InvalidRequestError.new("#{self.class}: #{msg}")
      end
    end
  end
end

TmxGit::Push::Cli.new.run(ARGV)

