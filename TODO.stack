basic game (as a separate module)
structure viz (ASCII)
something about config files parsing like commmand line arguments
game model
(explode "basic game" into milestones for a new phase)
(below is the end of the phase)
sessions
slack
IRC
telnet
scheduler
look at JSON parsing
look at pack/unpack
start kicker
is inotify a thing
basic IPC between processes in python
  many lessons
  commit the markdown that is a snapshot of the TOC
  that one-off
cover: parameters integrated into a hello world
  wish: consts not strings (or enum type)
  cover: the behavior when a parameter isn't found
  refactor: use `yield` in description functions
  cover: modeling parameters
  cover: the magnet on the failure path
  cover: the magnet on the success path
  cover: test thing: tees, debugging output
  cover: the remaining memoizers in helper.py
  look into re efficiency
  look up doc string conventions again to figure out if that extra line is right
sub-project: proof-of-concept search tool "JSON grep"
  [reserved for final cleanup & overflow]
  integrate real search
  implement & cover real backend for search
  integrate dummy story - ajax-pagination YIKES
  [reserved for unforseen milestones]
  integrate dummy story - no pagination, hard-coded limit
  integrate (& redesign as necessary) full integration for indexing
  implement & cover real backend for "indexing"
  dummy ajax interface for "indexing"
  integrate with front - fudge time maybe
  real backend for indexing
  mocked frontend for indexing
XXX - static_files
get main out of the bundle names
get purple ranger etc out
sub-project: upload files to s3
  integrate everything
  some kind of coverage of these five cases integrated
  cover: backend s3 put (when succeed)
  cover: backend s3 put (when fail)
  do the yes/no dialog (when yes (mock response))
  do the yes/no dialog (when not understood)
  do the yes/no dialog (when no)
  detect any time anyone uploads a file (in any channel)
  detect any time anyone uploads a file (in one channel)
====
  commit: do fake work ASYNCHRONOUSLY
  (the below might could knock out the above buttons-related branch)
  commit: now, instead of sending a message, present buttons ASYNCHRONOUSLY (or not)
  commit: now, instead of sending a message, present buttons SYNCHRONOUSLY
  commit: get the bot to send a message to slack in response to the minmal event ASYNCHRONOUSLY
  commit: get the bot to send a message to slack in response to the minmal event SYNCHRONOUSLY
  visual: get the bot to send a message to slack in a REPL
  commit: visual demo with tasks in own file
  grind-down: visual demo with templates broken up
==
  after "sakin agac" acceptance, take a swing at #wish [#021] coverage testing
  integrate
  generate thumbs
  tag-based query
  show/hide commentary
  design (nonworking static layout)
  react tutorial
  sftp a static tree to heroku
(-tag-lyfe.1.1.01 publish one or more dim sum, integrated with lozenge grid)
(-tag-lyfe.1.1.02 read or skim every section, enter metadata into DIM SUM)
(-tag-lyfe.1.1.03 design & build out reactive losenge grid (not dynamic at first))
(-tag-lyfe.1.1.04 integrate all work thus far into nagel-halftone theme)
(-tag-lyfe.1.1.05 reactive version of full 3-layer parallax, as PoC)
(-tag-lyfe.1.1.06 reactive version forked from punchout verion PoC)
(-tag-lyfe.1.1.07 reactive version of oldschool style float left image PoC)
(-tag-lyfe.1.1.08 dim sum on every hugo theme haha. chose theme)
(-tag-lyfe.1.1.09 continue reading hugo docs up to making own theme, while DIM SUMing it)
(-tag-lyfe.1.1.10 gimp just enough to halftone the subject)
(-tag-lyfe.1.1.11 gimp just enough to get transparent fello (research bowie, nagel))
(-tag-lyfe.1.1.11.1 Index manually every theme with notes, resolve a set of zero to N themes you want to synthesize from.
(-tag-lyfe.1.1.11.1.1 Resolve a set of zero to N themes you want to synthesize from.
(-tag-lyfe.1.1.11.1.2 Assess theme 50 down to 1
(-tag-lyfe.1.1.11.1.3 Assess theme 100 down to 51
(-tag-lyfe.1.1.11.1.4 Assess theme 150 down to 101
(-tag-lyfe.1.1.11.1.5 Assess theme 200 down to 151
