the big question - slicer (G)->(B)
insane experment with [sa] - convert every `should eql` to etc and see diff (C)
fix [#ca-xx] => [#co-xx], â€¢ in md's, `_call`=>`call`, memoize vs lazy) (B)
try to simplify [ac]/[ze] procure bound call
no more call_API per se - frontload all expectations as a spy so you fail early
[tm] change actors and sessions to magnetics
[tm] no more Selective_Builder_Receiver_Sender_Methods
unify other tmx node-centric services (that big dependency graph)
unbreak [tmx]'s heart - use new API somehow to bring old tmx back
utility to replace (generate) greenlist, etc. 'tmx-notes.json'
-1 rewrite (simplify) the "test all" test runner to use this system
-2 rewrite (simplify) the quickie recursive runner to use this system
-3 write a task to update semi-real costs (a bash script loop)
-4 add a randomize option to the below (for now only toplevel, later etc)
-5 break up into N greenlist using imaginary costs, or a costs files (take into acct order)
-6 regenerate the punchlist with that crazy algo (might require renaming)
   you will need an internal, non-CLI, cross sidesystem API
   you will need some proper coverage for CLI
   order (custom per attribute)
   design & cover derived attribute (aggregative)
