the big question - slicer (G)->(B)
insane experment with [sa] - convert every `should eql` to etc and see diff (C)
unify table under [ze] and then re-apply this to [tmx] counts (covered, add totals row and fix layout)
fix [#ca-xx] => [#co-xx], â€¢ in md's, `_call`=>`call`, memoize vs lazy) (B)
try to simplify [ac]/[ze] procure bound call
use [sa] to convert etc to Stream_
-1 script to calculate costs [#tmx-011] then [#tmx-010]
-2 the cost-driven divvy algorithm [#tmx-012]
-3 unify other tmx node-centric services [#tmx-015]
[#tmx-018.3] primaries of the `select` operation should show up in the `test-all` screen
[#tmx-019] get fuzzy out of multimode scanner
(eventpoint event can go away to somewhere)
[ze] Expresser needs slight cleanup, should be simple model
(-4 cleanup the items between this one and -3)
-5 [br] is renovated when it is only datastore adapteres and the example app
HO cull/test/64-cli/10-intro_spec.rb
HO git/test/[ many CLI ]
HO tan_man/test/62-cli_spec.rb
when [tm] CLI: #open [#tm-059] invites
when all use of [br] API is weened off, cover new proc-based action adapter #open [#br-036]
consider trying to quash `make_action_making_actions_module`
consider trying to quash `make_action_class`
-6 [cs] have fun figuring out what to do with isomorpic methods client
-7 also: decide if entity library is deprecated (#open [#fi-034.1])
[#ze-008.2] glob values
finish what you started with expag (somewhere)
(there are many "hi. ##{}todo"-type lines in [fi])
explain MTk and associate the explanation with its nodes
([br]: N actions..)
([co]: 2 actions, API only)
([tr]: 2 actions but maybe no coverage, API only)
([bs]: 3 actions, API only)
([gv]: 2 actions, API only)
([st]: 3 actions, API only)
([f2]: 3 actions, API only)
([sl]: 4 actions, API only)
([cm]: 4 actions, API only)
[#ze-051] is same as valid value store - do anything about this now?
not used: common/test/expect-emission-meta.rb
unify emission class with the others..
fold-in expect emission (oldschool)
fold-in "fail early"
make names modern ("emission.rb")
(somewhere: multi-mode argument scanner away, for 2nd wave and [br] injection)
cull/test/54-operations/62-mutator/50-unmarshal_spec.rb
cull/test/54-operations/62-mutator/25-actions_spec.rb
cull/test/54-operations/37-upstream/50-map/50-markdown-vertical_spec.rb
cull/test/54-operations/37-upstream/50-map/25-markdown-horizontal_spec.rb
cull/test/54-operations/12-survey/91-aggregator_spec.rb
cull/test/54-operations/12-survey/74-reduce_spec.rb
smalls in [#cu-007]
cull/test/54-operations/12-survey/58-mutator_spec.rb
get to this to_special_boxxy_item_name_stream__  (function-via-string.rb:99)
you need this: added_function_call
so you need this: RecomposeSection_via_FunctionCalls_and_Section___
read all of [#005] about this
the key is getting to the persist call in the survey object..
you can get rid of "FunctionBasedAssociations_" move it to assoc/curried-functions
[ac] pluralton persistence dedicated tests!
finish one new magent
finish other new magnet
fix diff thing
rename all operator branch to feature branch YIKES
.to_symbolish_reference_scanner not .to_loadable_reference_stream (right?)
(that commit was -1.1.1)
ok so you want to get to getting every '.should' being converted 03:47:08
(that commit was -1.1.2)
rebase the branch with the `expect( ).to` fix
(that commit was -1.1.3)
use this new tool to change all of your own `expect` to `anticipate` or whatever
indented report: uber alles
THEN: refactor to better viz, i.e of calls in tests
(-1.3.N refactor your tupling to complement the hooks mesh
think about how your tupling can be recursive and lazy (still immutable)
understand Parser nodes - how can we unparse?
answer the question: what is the rel. between `def x_map` and the list of nodes? (in `parser/builder/defaults`)
location map - this is the key
clean up that crazy hack in an isolated commit
uses class-based reflection structures fully for its traversal
see if you can phase-in class-based reflection for just some of it
figure out a tiny test case for a proof of concept of how class-based can replace function-based "for free"
gather supposed requirements for these (we should be able to infer them from the current thing) maybe as notes in the test
inheritence (I)->(H)
lazy evaluation of constituencies (H)
arbitrarily prioritized arity evaluation (G)->(L)
these guys (L)->(N,O,P)
assert "any"-ness (N)->(J)
assert arities (O)->(J)
assert group membership (P)->(J)
injected context (F)->(G)
(these guys) (J)->(E,D,C)
(these guys) (K)->(H)
parse probablistic groups (E)->(K)
parse the aritites (D)->(K)
parse the "any" modifier (C)->(K)
