[#039]       [ defined attribute ]

[#038]
       #open [#here.1] the dream of unification (of normalization, then of
             the unifying theory of models and associations)

[#037]       "one ring" assimilation notes ..

             :[#here.5]: each qualifying facility in the universe will be tracked
             :[#here.D]: feature categories (placeheld)
             :[#here.C]: "phase 1" thru "phase 3" (placeheld)
             :[#here.B]: introduction to "meta-association" (placeheld)
             :[#here.A]: overview of "association theroy"

[#036]       failure tree expression..

[#035] #itch 1x (in situ in [hu]) it would be nice to get nothing from
             the actor at all to pollute the namespace of builder
             methods. (edit: probably throu using attrs alone, no actor)


[#034]       "entity" ..

             [#here.2] (in document)

       #open [#here.1] will eventually maybe sunset entity as-is, but
             that depends on [#br-045] sunset. the concept will live on..

             ( #was: track redundant or near-redundant argument scanner.
               #moved-to: [#co-xxx] )

[#033]       iambics..

[#032]       any result path (in [#016])

[#031] #hole
             ( #wont move [#ca-04[56]] to here )

[#030] #hole
             ( #was: dedund this [missing required exception construction] )

[#029]       temporaly related local trackings
             :[#here.B]:  [ xx]
             :[#here.A]:  [ toolkit ]
             ( #was: local redundancy )

[#028]       [stack]


[#027]       [store]  (ivar-based, mostly)

[#026] #track struct vs. actor - one is cold one is hot

[#025]       #parent-node: [#002] "formal vs. actual attributes.."

[#023]       #wish - when the time comes - track inheritence merging

[#022]       #track - this tracks two related phenomena, both typically
             marked by the implementation of a `normalize` method:

             1) the workaround (perhaps temporary perhaps not) for the
             change when methodic actor was assimilated by [fi] attributes.
             this is the the prickly problem of how/when we should
             "normalize" vis-a-vis the main method of
             `process_argument_scanner_passively`.

             2) more generally it may also be used to track "sessions"
             that do not have enclosed edit sessions (i.e in a reasonably
             small block) so they need to have this `normalize` called at
             user-determined times..
             (more on this at [#012.A].)

[#021] #watch future redundancy - reflect all method-based attributes (in [br])

[#020]       #watch or not to memoize method-based attributes (they are so light)

[#019]       similar implementations (2x in univ) of mocking a scanner
             around a single value for argument processing.

[#018]       let me count the ways we parse ..

[#017] #hole
             ( #was: meta-meta-associations justification )
             ( #was: long note about sandboxed module hack for tests )

[#016]       [ actor ]  (will move from [co])

[#015] #open near-term smalls & mediums near "one-ring"

             [#here.1] in-situ WRONG

[#014]       "the arity exegesis .." (:"parameter arity" & :"argument arity")

[#013] #hole
             ( #was: the defined attributes set structure )

[#012]       now the "normal normalization" algorithm (and its variants)..

             [#here.L] - low-level gotchas
             [#here.L.1]: where to advance the scanner after primary expression

             :[#here.K] [hole]

       #wish :[#here.J.4]: `nilify` as an option
             :[#here.J.3]: generally geared towards dynamic associations
             :[#here.J.2]: as a behavioral feature, aggregate all missing required
             :[#here.J.1]: (placeheld) we must stop on first unrecognized when ..

             :[#here.I]: where "ad-hoc normalization box" is still used

             :[#here.8]: track in the universe entity/collection operations
               related but different

             :[#here.7]: track similar normalization algorithms elsewhere
             in universe. (this is an older variant of what is now the central
             project of [#037.five])

             :[#here.F]: the pseudocode

             :[#here.E.4]: values already in the value store will be assumed
             to be already valid.

             :[#here.E.3]: values produced by defaulting procs must not
             be run through normalization.

             :[#here.E.2]: justifies the need for defaulting to be able to fail
             and recommends an interface for handling and expressing (or not)
             this failure.

             :[#here.E.1]: introduces defaulting as it applies to the algorithm

             :[#here.D.2]: tracks where such ordered boxes are used in
             the universe.

             :[#here.D.1]: jusitifies why we keep "ad-hoc normalizer" as a
             simple proc and not for example a mutable, ordered set ("box").

             :[#here.3.2]: offers a counter-argument against "over-munging",
             that is, the idea that defaulting and required-ness are just
             specialized forms of "ad-hoc normalization", and so should be
             represented that way.

             :[#here.3]: is the start of the "one ring" algorithm (just
             discussion around it, really)

             :[#here.B]: in a model definition where every association is
             required (and ergo (in the old logic) none are defaultant),
             there is no need for a special call to `normalize` on the
             entity. (but what about requiredness check?)

             :[#here.A]: in our one-generation-ago algorithm, we posit and
             explore the significance of "normalization points" as a single,
             arbitrary but chosen point in time (for defaulting, for
             requiredness-check).

             (from the original [sl] description:)

             this tag tracks code instances of the general algorithm
             (and variant algorithms towards the same end) of
             implementing behavior that implements the validation &
             normalization of actual
             { arguments | attributes | parameters | properties };
             #normalization #algorithm
             more on the above at "unified language" [#012.appendix-A]

             ( #was: #done redesign this `with_client` nonsense )

[#010]       the external functions experiment ..

[#009] #hole
             ( #was: meta-attributes .. )
             ( #was: transplant "parameters" from [hl] )

[#008]       borrow/lend coverage
             [#here.14] lend to [sn]
             [#here.10-13] borrow
             [#here.6], [#here.7], [#here.8], [#here.9] borrow
             [#here.2], [#here.3], [#here.4], [#here.5] borrow
             [#here.A] #in-situ [ the absorber method maker ]

[#007]       small internal placeholders/notes (mostly)

       #track :[#here.E]: when `false` became `nil`

       #wish :[#here.D]: make configurable the assumption about the
                         "parameter arity" of associations. currently
                         `required` is assumed

       #hole :[#here.C]:

       #hole :[#here.B]:

             :[#here.1]: [ SESSION PATTERN ] (referenced universally)

[#006]       [ struct ]
             ( #was: old reference code from [ta] for for retrospective )

[#005]       [ from ]

[#004]       [ basic fields ]

[#003] #hole

[#002]       common association meta-associations ..
[#001]       discussion of all the property libs ..
