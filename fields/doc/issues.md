[#039]       [ defined attribute ]

[#038]       meta-meta-attrirubtes justification ..
       #open [#here.1] the dream of unification (of normalization, then of
             the unifying theory of models and associations)

[#037]       meta-attributes justification ..

             :[#here.5]: each qualifying facility in the universe will be tracked
             :[#here.D]: feature categories (placeheld)
             :[#here.C]: "phase 1" thru "phase 3" (placeheld)
             :[#here.B]: introduction to "meta-association" (placeheld)
             :[#here.A]: overview of "association theroy"

[#036]       failure tree expression..

[#035] #itch 1x (in situ in [hu]) it would be nice to get nothing from
             the actor at all to pollute the namespace of builder
             methods. (edit: probably throu using attrs alone, no actor)


[#034]       "entity" ..

             [#here.2] (in document)

       #open [#here.1] whether or not this is deprecated, wait till #open [#br-045] sunset
             ( #was: track redundant or near-redundant argument scanner.
               #moved-to: [#co-xxx] )

[#033]       iambics..

[#032]       any result path (in [#016])

[#031] #open move [#ca-04[56]] to here

[#030] #open dedund this

[#029]       in situ track universal redundancy

[#028] #open do *not* implement with [br] - break this tie..
             ( and [stack] )


[#027]       [store]  (ivar-based, mostly)

[#026] #open struct vs. actor - one is cold one is hot

[#025]       #parent-node: [#002] "formal vs. actual attributes.."

[#023]       #wish - when the time comes - track inheritence merging

[#022]       #track - this tracks two related phenomena, both typically
             marked by the implementation of a `normalize` method:

             1) the workaround (perhaps temporary perhaps not) for the
             change when methodic actor was assimilated by [fi] attributes.
             this is the the prickly problem of how/when we should
             "normalize" vis-a-vis the main method of
             `process_argument_scanner_passively`.

             2) more generally it may also be used to track "sessions"
             that do not have enclosed edit sessions, so they need to
             have this `normalize` called at user-determined times..
             (more on this at [#012.A].)

[#021] #watch future redundancy - reflect all method-based attributes (in [br])

[#020]       #watch or not to memoize method-based attributes (they are so light)

[#019]       similar implementations (2x in univ) of mocking a scanner
             around a single value for argument processing.

[#018]       let me count the ways we parse ..

[#017] #hole
             ( #was: long note about sandboxed module hack for tests )

[#016]       [ actor ]  (will move from [co])

[#015]       track assimiliation targets "missing"

[#014]       "the arity exegesis .." (:"parameter arity" & :"argument arity")

[#013]       the unification of methodic actors into (here) "attributes"

[#012]       now the "normal normalization" algorithm (and its variants)..

             :[#here.I]: where "ad-hoc normalization box" is still used

             :[#here.8]: track in the universe entity/collection operations
               related but different

             :[#here.7]: track similar normalization algorithms elsewhere
             in universe. (this is an older variant of what is now the central
             project of [#037.five])

             :[#here.F]: marks the beginning of the one-generation-old
             algorithm.. :[#here.F.1]: is the old (and now defunct) idea that
             a defaultant association MUST NOT be required. (other sub-tags
             here track a logical reduction of the grammar space.)

             :[#here.E]: justifies the need for defaulting to be able to fail
             and recommends an interface for handling and expressing (or not)
             this failure.

             :[#here.D.2]: tracks where such ordered boxes are used in
             the universe.

             :[#here.D.1]: jusitifies why we keep "ad-hoc normalizer" as a
             simple proc and not for example a mutable, ordered set ("box").

             :[#here.C]: offers a counter-argument against "over-munging",
             that is, the idea that defaulting and required-ness are just
             specialized forms of "ad-hoc normalization", and so should be
             represented that way.

             :[#here.B]: in a model definition where every association is
             required (and ergo (in the old logic) none are defaultant),
             there is no need for a special call to `normalize` on the
             entity. (but what about requiredness check?)

             :[#here.A]: in our one-generation-ago algorithm, we posit and
             explore the significace of "normalization points" as a single,
             arbitrary but chosen point in time (for defaulting, for
             requiredness-check).

             (from the original [sl] description:)

             this tag tracks code instances of the general algorithm
             (and variant algorithms towards the same end) of
             implementing behavior that implements the validation &
             normalization of actual
             { arguments | attributes | parameters | properties };
             #normalization #algorithm
             more on the above at "unified language" [#012.appendix-A]

             ( #was: #done redesign this `with_client` nonsense )

[#010]       the external functions experiment ..

[#009]       meta-attributes ..
             ( #was: transplant "parameters" from [hl] )

[#008]       borrow/lend coverage
             [#here.6], [#here.7], [#here.8], [#here.9] borrow
             [#here.2], [#here.3], [#here.4], [#here.5] borrow
             [#here.A] #in-situ [ the absorber method maker ]

[#007]       small internal placeholders/notes (mostly)

       #track :[#here.E]: when `false` became `nil`

       #wish :[#here.D]: make configurable the assumption about the
                         "parameter arity" of associations. currently
                         `required` is assumed

       #open :[#here.C]: defaults can now fail a requiredness check

             :[#here.B]: we need a proper placeholder for "attribues actor"

             :[#here.1]: [ SESSION PATTERN ] (referenced universally)

[#006]       [ struct ]
             ( #was: old reference code from [ta] for for retrospective )

[#005]       [ from ]

[#004]       [ basic fields ]

[#003]       the declared fields narrative .. (this will assimilate to [#013])

[#002]       the attribute narrative ..
[#001]       discussion of all the property libs ..
