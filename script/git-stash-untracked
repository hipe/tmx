#!/usr/bin/env ruby -w

require 'fileutils'
require 'open3'
require 'pathname'


require File.expand_path('../../lib/skylab/porcelain/all', __FILE__)

module Skylab::GitStashUntracked
  class Porcelain
    extend ::Skylab::Porcelain

    DRY_RUN = ->(ctx) { on('-n', '--dry-run', "Dry run.") { ctx[:dry_run] = true } }
    STASHES = ->(ctx) do
      ctx[:stashes] = '../Stashes'
      on('-s', '--stashes <dir>', "where to put the files (default: #{ctx[:stashes]})") { |v| ctx[:stashes] = v }
    end

    option_syntax do |ctx|
      instance_exec ctx, &DRY_RUN
      instance_exec ctx, &STASHES
    end
    argument_syntax "<name>"
    def save name, opts
      Plumbing::Save.new(@runtime, opts.merge(:name => name)).invoke
    end

    option_syntax do |ctx|
      instance_exec ctx, &STASHES
    end
    def list opts
      Plumbing::List.new(@runtime, opts).invoke
    end

    option_syntax do |ctx|
      instance_exec ctx, &STASHES
    end
    argument_syntax '<name>'
    def show name, opts
      Plumbing::Show.new(@runtime, opts.merge(:name => name)).invoke
    end

    option_syntax do |ctx|
      instance_exec ctx, &DRY_RUN
      instance_exec ctx, &STASHES
    end
    argument_syntax '<name>'
    def pop name, opts
      Plumbing::Pop.new(@runtime, opts.merge(:name => name)).invoke
    end

    def status
      num = Plumbing::Save.new(@runtime).each_file { |fn| @runtime.emit(:payload, fn) }
      0 == num and @runtime.emit(:info, "# (no untracked files)")
      true
    end
  end
  class Plumbing
    def collection
      Collection.cache[stashes] ||= Collection.new(stashes, :dry_run => @dry_run) { |*a| emit(*a) }
    end
    attr_accessor :dry_run
    def emit a,b ; @runtime.emit(a, b) end
    def failed msg
      emit(:error, "failed: #{msg}")
      false
    end
    def initialize runtime, request={}
      @dry_run = false
      request.each { |k, v| send("#{k}=", v) }
      @runtime = runtime
    end
    attr_accessor :name
    attr_accessor :stashes
  end
  class Plumbing::Save < Plumbing
    COMMAND = 'git ls-files -o --exclude-standard'
    def each_file
      count = 0
      emit :info, "# #{COMMAND}"
      Open3.popen3(COMMAND) do |_, sout, serr|
        loop do
          "" == (e = serr.read) or return emit(:error, e)
          line = sout.gets or break
          count += 1
          yield line.strip
        end
      end
      count
    end
    def invoke
      stash = collection.stash(@name).validate_for_writing or return stash
      none = true
      each_file { |file| stash.stash_file file; none = false }
      none and emit(:info, "no files to stash!")
      true
    end
  end
  class Plumbing::List < Plumbing
    def invoke
      collection.validate_existence or return false
      count = 0
      collection.each_stash do |stash|
        count += 1
        emit :payload, stash.name
      end
      count
    end
  end
  class Plumbing::Show < Plumbing
    attr_accessor :format
    def invoke
      @format ||= :stat
      (stash = collection.stash(name)).validate_existence or return false
      stash.each_show_line(@format, &method(:emit))
    end
  end
  class Plumbing::Pop < Plumbing
    def invoke
      emit :info, "OK whatever"
    end
  end
  class Collection
    @cache = {}
    def each_stash
      @path.exist? or raise RuntimeError.new("no such directory: #{@path}")
      Dir.new(@path.to_s).each do |name|
        name[0,1] == '.' and next
        yield stash(name)
      end
      nil
    end
    def initialize path, opts, &block
      @cache = {}
      @emit = block
      @opts = opts
      @path = Pathname.new(path)
    end
    def stash name
      @cache[name] ||= Stash.new(@path, name, @opts, &@emit)
    end
    def validate_existence
      @path.exist? and return true
      @emit[:error, "Stashes dir does not exist: #{@path}"]
      false
    end
  end
  class << Collection
    attr_reader :cache
  end
  class Stash
    include FileUtils
    attr_accessor :dry_run
    def each_show_line format, &emit
      PatchMaker[pathname, &emit]
    end
    def failed msg
      @emit[:error, "Couldn't stash. #{msg}"]
      false
    end
    def fu_output_message msg
      @emit[:info, "#{msg}"]
    end
    def initialize dirpathname, stash_name, opts, &emit
      @dry_run = false
      @valid = false
      @dirpathname = dirpathname
      @emit = emit
      @quiet = {}
      @name = stash_name.to_s
      opts.each { |k, v| send("#{k}=", v) }
    end
    attr_reader :name
    def stash_file file
      @valid or validate_for_writing or return false
      dest = pathname.join(file)
      dest.dirname.exist? or (@quiet[dest.dirname.to_s] ||= mkdir_p(dest.dirname, :verbose => true, :noop => @dry_run))
      move(file, dest, :verbose => true, :noop => @dry_run)
    end
    def pathname
      @pathname ||= @dirpathname.join(@name)
    end
    def validate_existence
      pathname.exist? and return true
      failed("stash does not exist: #{name}")
    end
    def validate_for_writing
      if pathname.exist?
        (d = Dir["#{pathname}/*"]).any? and
          return failed("Destination dir must be empty (\"stash\" already exists?).  Found files:\n#{d.join("\n")}")
      elsif ! @dirpathname.exist?
        return failed("Stashes directory must exist: #{@dirpathname}")
      else
        # a directory needs to be made, but make it when there are files to move
      end
      @valid = true
      self
    end
  end
  module PatchMaker ; end
  class << PatchMaker
    include FileUtils
    def [] (path, &emit)
      File.directory?(path) or raise("not a directory: #{path}")
      each_path = ->(path) do
        emit[:payload, '--- /dev/null']
        emit[:payload, "+++ #{path.sub(/^\./, 'b')}"]
        lines = File.read(path).split("\n", -1)
        if '' == lines.last
          lines.pop
        else
          # ...
        end
        emit[:payload, "@@ -0,0 +1,#{lines.count}"]
        lines.each { |line| emit[:payload, "+#{line}"] }
      end
      cd(path) do
        Open3.popen3('find . -type f') do |_, sout, serr|
          '' != (s = serr.read) and raise("nope: #{s}")
          while s = sout.gets do each_path[s.strip] end
        end
      end
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  ::Skylab::GitStashUntracked::Porcelain.new{ on_all { |e| $stderr.puts e } }.invoke(ARGV)
end

