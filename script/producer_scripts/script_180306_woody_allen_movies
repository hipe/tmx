#!/usr/bin/env python3

"""
plot the dates of woody allen movies in a one-dimensional scatterplot

broadly there are 3 steps to this:

    - download the html (write it to a tmp file)

    - scrape the html for the year of the movies (write it to a json file)

    - turn the list of years into a MINIMALLY simple visualization
      (a "one dimensional scatterplot")
"""


raise Exception('not covered')  # [#676] cover me. worked at #history-A.1
# NOTE - this writes tempfiles so take that into account when you cover


_doc = __doc__  # grab the above as our UI docstring before below


# TODO (we don't yet want these in a versionsed Pipfile because it would
# be a very weak development dependency, and we want to hold off on any
# dependencies for now..)

"""
dependencies (TODO):
    - beautifulsoup4   4.6.0
    - matplotlib       2.1.2
    - numpy            1.14.1
    - requests         2.18.4
"""


url = 'https://en.wikipedia.org/wiki/Woody_Allen_filmography'

tmp_numbers_file = 'tmp.woody-allen.numbers.list'
tmp_html_file = 'tmp.woody-allen.page.html'


def _execute_into(client, argv):

    def __main():
        ok, do_thing = __parse_argv()
        if not ok:
            return exitstatus

        ok = __resolve_html_file()
        if not ok:
            return exitstatus

        ok = __resolve_numbers()
        if not ok:
            return exitstatus

        return _display_thing(client, do_thing)

    def __resolve_numbers():
        if client.path_exists(tmp_numbers_file):
            client.info('(using {})', tmp_numbers_file)
            return True
        else:
            return _write_numbers_file(client)

    def __resolve_html_file():
        if client.path_exists(tmp_html_file):
            client.info('(using {})', tmp_html_file)
            return True
        else:
            return _write_html_file(client)

    def __parse_argv():
        program_name, *rest = argv
        leng = len(rest)
        if 0 == leng:
            return True, False
        this_one_option = '--use-numpy'
        do_explain = False
        if 1 == leng:
            tok, = rest
            if tok == this_one_option:
                return True, True
            if tok in ('-h', '--help'):
                do_explain = True
            else:
                client.error(f"unrecognized option/argument '{tok}'")
        else:
            client.error('too many arguments')

        client.info(f'usage: {program_name} [--help|--use-numpy]')
        if do_explain:
            for line in __do_explain():
                client.stderr.write(f'{line}\n')
        return False, None

    def __do_explain():
        itr = (line for line in _doc.split('\n') if len(line))
        yield f'description: {next(itr)}'
        for line in itr:
            yield line
        yield 'options:'
        yield '    --use-numpy  do the full monty. requires things'

    exitstatus = 5

    return __main()


def _display_thing(client, do_thing):

    float_a = tuple(__floats_via_file())
    if do_thing:
        __display_thing_using_numpy(client, float_a)
    else:
        __display_thing_simply(client, float_a)


def __display_thing_using_numpy(client, float_a):
    """(adapted from K.-Michael Aye's work stack overflow)"""

    import numpy as np
    import matplotlib.pyplot as pp

    val = 0.  # this is the value where you want
    # the data to appear on the y-axis.

    ar = [float_a]
    pp.plot(ar, np.zeros_like(ar) + val, 'x')
    client.info('(showing. close window there to return.)')
    pp.show()


def __display_thing_simply(client, float_a):
    io = client.stdout
    count = 0
    for f in float_a:
        count += 1
        io.write('%0.2f\n' % f)
    client.info('({} items total)', count)


def __floats_via_file():

    import json
    with open(tmp_numbers_file) as fp:
        for line in fp:
            _row = json.loads(line)
            yield float(_row['year'])


def _write_numbers_file(client):
    from bs4 import BeautifulSoup
    with open(tmp_html_file) as fp:
        soup = BeautifulSoup(fp, 'html.parser')

    tables = soup.find_all(None, 'wikitable')
    ln = len(tables)
    exp = 4
    if ln is not exp:
        client.error('expected {} had {} tables', exp, ln)
        return False

    table = tables[0]
    del tables

    itr = iter(table.find_all('tr'))
    next(itr)  # skip header row (1 of 2)
    next(itr)  # skip header row (2 of 2)

    def f():
        """there's always only ever one movie per table row. however, when

        there's multiple movies in a year, this little dance happens:
        there's one row whose year cel has a greater-than-one `rowspan`.
        then, the N-1 subsequent rows will each have a number of cels that
        is *one less* than normal number (because they each don't-need-and-
        must-not-have their own year cel).

        the way we handle this below is rough with redundancy because it's
        a one-off, but note there are three `yields` below for the three
        kinds of rows we will encounter (1: easy rows, 2: the first row in
        group, and 3: the subsequent rows in a group.)
        """

        for tr in itr:
            tds = tr.find_all('td')
            year_td = tds[0]
            year = int(year_td.text)
            rowspan_s = year_td.get('rowspan')
            if rowspan_s is None:
                yield(0.5 + year, tds[1].text)
            else:
                num_rows = float(rowspan_s)
                numerator_int = 1
                denom_float = num_rows + 1   # ick: 3 rows: 1/4 2/4 3/4

                yield((1.0*numerator_int/denom_float)+year, tds[1].text)
                while True:
                    numerator_int += 1
                    tr = next(itr)
                    tds = tr.find_all('td')
                    yield((1.0*numerator_int/denom_float)+year, tds[0].text)

                    if numerator_int == num_rows:
                        break

    import json
    count = 0
    with open(tmp_numbers_file, 'w') as fp:
        for (year_f, movie_name) in f():
            _json = json.dumps({'year': year_f, 'movie_title': movie_name})
            fp.write(_json + '\n')
            count += 1

    client.info("wrote {} lines to {}", count, tmp_numbers_file)
    return True


def _write_html_file(client):
    import requests
    with open(tmp_html_file, 'w') as fh:
        r = requests.get(url)
        status_code = r.status_code
        if status_code is 200:
            _bytes = fh.write(r.text)
            client.info('wrote {} ({} bytes)', tmp_html_file, _bytes)
            ok = True
        else:
            client.error('bad status code: {}', status_code)
            ok = False
    if not ok:
        client.remove_file(tmp_html_file)
    return ok


class _Client:
    """("modality" "injection")"""

    def __init__(self, sin, sout, serr):
        self.stdin = sin
        self.stdout = sout
        self.stderr = serr

    def remove_file(self, path):
        import os
        os.remove(path)

    def path_exists(self, path):
        import os
        return os.path.exists(path)

    def error(self, fmt, *args):
        self._same(fmt, args)

    def info(self, fmt, *args):
        self._same(fmt, args)

    def _same(self, fmt, args):
        self.stderr.write(fmt.format(*args)+'\n')


if __name__ == '__main__':
    import sys
    _client = _Client(sys.stdin, sys.stdout, sys.stderr)
    exit(_execute_into(_client, sys.argv))

# #history-A.1
# #born.
