#!/usr/bin/env bash

# constants (""):

file='z/times'

# parsing argv sets these:

is_supplemental=''
is_date=''
do_echo=''
do_help=''
do_invite=''

# we can't reach ARGV via $#, $1 etc from within functions, so imagine using
# BASH_ARGV universally instead. issues/gotchas with that:
# ðŸ‘‰ BASH_ARGV is a stack so the elements are in reverse order from ARGV
# ðŸ‘‰ we lose the elegance of `shift` (which doesn't mutate BASH_ARGV)
# ðŸ‘‰ BASH_ARGV appears to be immutable magic: assigning to it silently fails
# ðŸ‘‰ it's bad style to litter our code with lots of refs to a magic global.
# so:

bash_argv=("${BASH_ARGV[@]}")

# parse-off business options from the "front" (top of stack)

# always keep `len` current because it is a file-global, used everywhere.
len="${#bash_argv[@]}"
while [ "$len" -ne 0 ]; do

  # negative offsets are a new feature of bash not supported in mine at writing
  arg="${bash_argv[$len - 1]}"

  # keep parsing IFF argument starts with a dash and is two chars long
  if [[ ! "$arg" =~ ^-.$ ]]; then
    break
  fi

  # substring in bash: start from offset 1, length 1
  char="${arg:1:1}"

  case "$char" in
    's')
      is_supplemental=1
      ;;
    'd')
      is_date=1
      ;;
    'e')
      do_echo=1
      ;;
    *)
      # the first unrecognized flag is left at the head (top) of the stack
      break
      ;;
  esac

  # array pop in bash (1 of 2) (what we do instead of `shift`)
  unset 'bash_argv[$len - 1]'
  ((len --))
done

# It's of no value to have a timetracking file with timestamps but no
# descriptions (or blank lines) so <message> is generaly required. However:
# the --echo option exists mainly to get (possibly just) the formatted (maybe
# date and) time output to STDOUT, so for this case we annul the requirement.
# --supplemental is explicitly for adding additional lines to a multi-line
# description, so this requires a message. As such, a message is required for
# all cases except when -e and not -s.

if [[ -n "$do_echo" && -z "$is_supplemental" ]]; then
  message_is_required=''
else
  message_is_required=1
fi


if [ -t 0 ]; then
  is_interactive=1
else
  is_interactive=''
fi


validate() {

  # (in a function so we can short-circuit out of it early with return lol)

  # look for more specific errors first before more general ones, because
  # it's super confusing getting a generic error message when the underlying
  # cause of the error is something more specific

  if [[ -n "$is_date" && -n "$is_supplemental" ]]; then
    nope "-d and -s are mutually exclusive"
    return
  fi

  # if more arguments
  if [ "$len" -ne 0 ]; then

    # see "negative offsets" above)
    arg="${bash_argv[$len - 1]}"

    # if it looks like an option
    if [[ "$arg" =~ ^- ]]; then

      # if it looks like a 'stop parsing' operative
      if [[ "$arg" =~ ^--?$ ]]; then

        # array pop in bash (2 of 2)
        bash_argv=("${bash_argv[@]:0:$len - 1}")
        ((len --))

      else
        if [[ "$arg" =~ ^-(h|-help)$ ]]; then
          do_help=1
          # exit early. don't parse remaining args or validate missing args
          return
        fi
        nope "unrecognized option: \"$arg\""
        return
      fi
    fi
  fi

  message_is_provided=''

  if [[ -z "$is_interactive" ]]; then
    if [[ "$len" -ne 0 ]]; then
      nope "can't read from both STDIN and args"
      return
    fi
    message_is_provided=1
    seen=''
    while read line; do
      if [ -n "$seen" ]; then
        nope "for now can't have more than one line in STDIN"
        return
      fi
      seen=1
      line_read_from_stdin="$line"
    done
    if [ -z "$seen" ]; then
      nope "no lines were in STDIN"
      return
    fi
    if [ -z "$line_read_from_stdin" ]; then
      nope "xx yy zz"
      return
    fi

  elif [[ "$len" -ne 0 ]]; then
    message_is_provided=1
  fi

  if [[ -n "$message_is_required" && -z "$message_is_provided" ]]; then
    nope "expecting <msg1> .."
  fi
}


nope() {
  echo "$1" >&2
  do_invite=1
}


validate

if [ -n "$do_invite" ]; then
  echo "use \"$0 -h\" for help" >&2
  exit 5
fi

if [ -n "$do_help" ]; then
  echo "usage: $0 [-d|-s] [-e] [-[-]] msg1 msg2 .." >&2
  echo "" >&2
  echo "description: append a timestamp line to ${file}" >&2
  echo "             (our minimal time tracking system)" >&2
  echo "" >&2
  echo "options:" >&2
  echo "    -d    date. uglyly include month-day in timestamp" >&2
  echo "    -s    supplemental. only appends message, no timestamp" >&2
  echo "    -e    echo the would-be appended line to STDOUT and exit" >&2
  echo "    -, -- stop parsing subsequent arguments for options" >&2
  exit 0
fi

if [ -n "$is_date" ]; then
  da=$(date '+%m-%d %H:%M:%S')
elif [ -n "$is_supplemental" ]; then
  da='              '
else
  da=$(date '+      %H:%M:%S')
fi

if [ "$len" -eq 0 ]; then
  if [ -z "$is_interactive" ]; then
    tail_string="  $line_read_from_stdin"
  else
    tail_string=""
  fi
else
  # array reverse in bash. (one way of several)
  args=()
  for (( i="$len" - 1; i > -1; i-- )); do
    args+=("${bash_argv[$i]}")
  done
  tail_string="  ${args[@]}"
fi

line="  ${da}${tail_string}"

if [ -n "$do_echo" ]; then
  echo "$line"
  exit 0
fi

if [ ! -f "$file" ]; then
  echo "for now, file must exist: $file" >&2
  exit 5
fi

echo "(did: echo \"$line\" >> $file)" >&2
echo "$line" >> "$file"
