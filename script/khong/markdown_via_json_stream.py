#!/usr/bin/env python3 -W error::Warning::0

"""produce the markdown (custom format) for Dr. K Hong's excellent thing

(this is the content-consumer of the producer/consumer pair)
"""


"""
internal discussion:

the immediate objective of this is to generate the markdown table from
the producer stream.

in implementation this is a mostly straightforward mapping:
  - (output the head of the markdown document)
  - recognize and no-op the first line item (metadata)
  - recognize and no-op section header line items
  - with every other line item, output it as a markdown table row
  - (output the tail of the markdown document)

nowadays, we would ideally accomplish this by "seeding" the markdown
document with a starter document and then using the `sync` script;
a procedure that is certainly under the mandate of the sync script and
one that would obviate this entire subject script.

but for now we cover the subject script as-is because:

  - at writing we haven't yet covered this use case

  - apart from the question of the above issue of using the sync script,
    this script exhibits other would-be conventions of of the producer-
    consumer pattern in practice (conventions we want to cover) like:

      - reading from a stream of JSON objects in standard input.

      - broadly, some kind of integration with CLI

also, it's worth noting somewhere that this script has historical
significance because it was the old way that we were gonna detect changes
in the upstream data source (#open [#410.J]), by keeping a versioned
instance of the markdown table generated by this script, and re-running
the script periodically to see when the output is different.
"""


def _my_CLI(listener, program_name, sin, sout, serr):
    from modality_agnostic import listening as li
    if sin.isatty():
        o = li.leveler_via_listener('error', listener)
        o('currently, non-interactive from STDIN only')
        o('e.g: blab_blah | {}', program_name)
        return 5
    else:
        info = li.leveler_via_listener('info', listener)
        import json

        def f():
            for line in sin:
                _hsh = json.loads(line)
                yield _hsh
        n1, n2 = flush_markdown_into_via_object_stream(sout, f(), listener)
        info('emitted {} row-items, {} bytes', n1, n2)
        return 0


def flush_markdown_into_via_object_stream(sout, itr, listener):
    """result in number of bytes written"""

    # #todo - this would be better as a generator than as what we do
    # here but we don't expect this to stay ..

    import script_lib as sl

    o = sl.putser_via_IO(sout)

    o('| Lesson | Read | Emoji | Notes |')
    o('|----|:---|:---|---:|')

    byts = 0
    items = 0

    meta = next(itr)
    meta['_is_sync_meta_data']  # assert that it exists

    for hsh in itr:
        if 'header_level' in hsh:
            continue  # flatten sections
        items += 1
        # for probably one particular erroneous guy
        byts += o('|{}|◻️|◻️||'.format(hsh['lesson']))

    return (items, byts)


_max_name_width = 70


def _CLI(sin, sout, serr, argv):  # #testpoint

    def cli_function(listener, sin, sout, serr):
        return _my_CLI(listener, program_name, sin, sout, serr)

    cli_function.__doc__ = _use_this_doc

    program_name = argv[0]

    import script_lib as sl
    _exitstatus = sl.CHEAP_ARG_PARSE(
            cli_function=cli_function,
            std_tuple=(sin, sout, serr, argv),
            )
    return _exitstatus


_use_this_doc = __doc__


if __name__ == '__main__':
    import sys as o
    o.path.insert(0, '')
    _exitstatus = _CLI(o.stdin, o.stdout, o.stderr, o.argv)
    exit(_exitstatus)

# #born: abstracted from sibling
