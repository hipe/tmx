module Skylab::CodeMetrics

#== this is about to be ridiculous

  if ridiculous_
    @ridiculous_ = false

    class CLI__ExpressMondrianHelp_via_ < Common_::MagneticBySimpleModel

      attr_writer(
        :expression_agent,
        :program_name_string_array,
        :stderr,
      )

      def execute

        _Help = Zerk_lib_[]::NonInteractiveCLI::Help

        h = PRIMARY_DESCRIPTIONS___

        _Help::ScreenForEndpoint.express_into @stderr do |o|
          o.expression_agent @expression_agent
          o.primary_symbols h.keys
          o.express_usage_section @program_name_string_array.join SPACE_
          o.express_items_sections h
        end
        ACHIEVED_  # probably ignored
      end

      _Low = ::Skylab_CodeMetrics_Operations_Mondrian_EarlyInterpreter

      PRIMARY_DESCRIPTIONS___ = {

        # (only because no other modality currently expresses this help
        # content, the descriptions for primaries from the two different
        # concerns are mixed together "by hand" here. an added "benefit"
        # to this is we can control relative position (order) plainly.)

        path: -> y do
          y << "adds this path to the list of paths to be loaded."
          y << "if you use globs, put them in single quotes."
          y << "because this is the default primary, using the `-path`"
          y << "switch itself is probably never necessary."
        end,

        width: -> y do
          y << "how wide the outermost rectangle is"
          y << "(in characters) (default: #{ _Low::WIDTH })"
        end,

        height: -> y do
          y << "how high the outermost rectangle is"
          y << "(in characters) (default: #{ _Low::HEIGHT })"
        end,

        head_const: -> y do
          y << "for now, is necessary for some reason #todo."
          y << "modules that are not under this module are filtered out."
          y << "for now, #{ prim :head_path } is derived from this."
        end,

        head_path: -> y do
          y << "hm.."
        end,

        require_path: -> y do
          y << "any path that you would require from a script"
          y << "can be expressed multiple times"
        end,

        list_nodes_to_load: -> y do
          y << "skips normal output; just shows the \"nodes\""
          y << "that would be loaded"
        end,

        verbose: -> y do
          y << "verbose output"
        end,

        ping: -> y do
          y << "to see if it's working"
        end,
      }
    end
  else
#== that was ridiculous
  Require_brazen_[]  # 2 of 2

  class CLI < Brazen_::CLI

    Add_lipstick_field_ = -> defn, column_for_count do

      ::Skylab::Zerk::CLI::HorizontalMeter.
          add_max_share_meter_field_to_table_design( defn ) do |o|

        o.for_input_at_offset column_for_count
        o.foreground_glyph PLUS___
        o.background_glyph SPACE_
      end
    end

    Flush_stream_into_ = -> out, out_st do
      begin
        line = out_st.gets
        line || break
        out.puts line
        redo
      end while above
    end

    HARD_CODED_WIDTH_ = 150
    PLUS___ = '+'
  end
  end  # ridiculous
end
# #tombstone: we used to have to do a lot of setup for lipsticker
