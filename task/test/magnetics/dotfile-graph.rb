module Skylab::Task::TestSupport

  module Magnetics::Dotfile_Graph

    def self.[] tcc
      tcc.include self
    end

    # -

      def dotfile_graph_reflection_via_ * s_s_a

        _tss = token_stream_stream_via_ s_s_a
        _itc = item_reference_collection_via_item_resolver_and_token_stream_stream_ nil, _tss
        o = magnetics_module_
        _fi = _itc.function_index_
        _dfg = o::DotfileGraph_via_FunctionIndex[ _fi ]
        Reflection.via_line_stream _dfg
      end

    # -

    # ==

    class Reflection

      # a *simple*, *not general purpose* hand-written line-based parser
      # attempts to index the dotfile into structures useful for testing.
      #
      # this parser only exists to parse dotfiles generated by this library,
      # and will break as soon as we try to do anything that deviates from
      # the very restrictive set of assumptions we make here:
      #
      # we disallow blank lines, comments, semicolons, and much much else
      # of the `dot` laguage. (if we wanted a full-blown parser there's
      # [ta] but we definitely don't want that.)
      #
      # if we were to write the "grammar" we implement here in EBNF it would
      # look something like:
      #
      #     document          = beginning line, { body line }, ending line
      #
      #     beginning line    = "digraph g {\n"
      #
      #     ending line       = "}\n"
      #
      #     body line         = association line | node line
      #
      #     association line  = margin, ref, space, "->", space, ref, "\n"
      #
      #     node line         = margin, ref, space, '[label="', label, '"]\n'
      #
      #     (* ref            =  see regexp #here  *)
      #
      #     margin            = whitespace char, { whitspace char }
      #
      #     whitespace char   = space | "\t"
      #
      #     space             = " "

      class << self
        alias_method :via_line_stream, :new
        undef_method :new
      end  # >>

      def initialize st

        @_label_via_reference_box = Common_::Box.new
        @_label_via_reference = @_label_via_reference_box.h_
        @_to_via_from = {}
        @_state = :__at_beginning

        buffer = ""

        begin
          line = st.gets
          line || break
          @_line = line
          send @_state
          buffer << line
          redo
        end while nil

        @ONE_BIG_STRING = buffer
      end

      opening_line = "digraph g {\n"

      define_method :__at_beginning do

        @_line == opening_line || fail
        @_state = :_probably_association ; nil
      end

      def _probably_association

        if _match_association
          _process_association

        elsif _match_node
          @_state = :_probably_node
          _process_node

        else
          _neither
        end
      end

      def _probably_node

        if _match_node
          _process_node

        elsif _match_association
          @_state = :_probably_association
          _process_association

        else
          _neither
        end
      end

      ref_rxs = '[_a-z0-9]+'  # #here

      assoc_rx = /\A[ \t]+(?<from>#{ ref_rxs }) -> (?<to>#{ ref_rxs })(?=$| \[label=)/

      define_method :_match_association do
        @_md = assoc_rx.match @_line
        @_md ? true : false
      end

      node_rx = %r(\A[ \t]+(?<ref>#{ ref_rxs })[ ]\[label="(?<label>[^"]+)"\]$)

      define_method :_match_node do
        @_md = node_rx.match @_line
        @_md ? true : false
      end

      def _process_association

        md = @_md
        from = md[ :from ].intern
        _to = md[ :to ].intern
        _h = @_to_via_from.fetch from do
          @_to_via_from[ from ] = {}
        end
        _h[ _to ] = true
        NIL_
      end

      def _process_node

        md = @_md
        _ref = md[ :ref ].intern
        _label = md[ :label ]

        @_label_via_reference_box.add _ref, _label
        NIL_
      end

      final_line = "}\n"

      define_method :_neither do
        remove_instance_variable :@_md
        if final_line == @_line
          remove_instance_variable :@_line
        else
          fail ___say_hack_failed
        end
      end

      def ___say_hack_failed
        "hack failed - failed to match #{ @_line.inspect }"
      end

      # --

      def label_for_ONE_OF_THESE_node doot_d
        label_for _oot doot_d
      end

      def label_for_ALL_OF_THESE_node daot_d
        label_for _aot daot_d
      end

      def label_for business_sym
        @_label_via_reference.fetch business_sym
      end

      def A_points_to_this_ONE_OF_THESE_node business_sym, doot_d
        _A_points_to_B business_sym, _oot( doot_d )
      end

      def this_ONE_OF_THESE_node_points_to_this_ALL_OF_THESE_node doot_d, daot_d
        _A_points_to_B _oot( doot_d ), _aot( daot_d )
      end

      def this_ONE_OF_THESE_node_points_to_B doot_d, business_sym
        _A_points_to_B _oot( doot_d ), business_sym
      end

      def this_ALL_OF_THESE_node_points_to_B daot_d, business_sym
        _A_points_to_B _aot( daot_d ), business_sym
      end

      def _oot doot_d
        :"_oot#{ doot_d }"
      end

      def _aot daot_d
        :"_aot#{ daot_d }"
      end

      def _A_points_to_B a_sym, b_sym

        _h = @_to_via_from.fetch a_sym
        _h[ b_sym ] || fail
      end

      attr_reader(
        :ONE_BIG_STRING,  # (see note where this is read)
      )
    end
  end
end
