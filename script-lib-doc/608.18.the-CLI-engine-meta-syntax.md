(todo XX: there's a lot of high-level documentation introducing "the engine"
in the engine test file which predates this document. We should melt and
re-house that content from there in to here.)


# Introducing the distinction between positionals and nonpositionals

Broadly, as a first step in taxonomizing and characterizing different CLI's
(and their underlying "engines" (if any)); we suggest at first separating
the discussion of "options" versus [positional] "arguments"; because they are
(by design) fundamentally different in how they look, how they are are parsed;
and what characteristics and concerns come along with them.

(Indeed, we will observe this in the discussion in the next section, when
we see that not all characteristics relevant to positionals are relevant to
nonpositionals and vice-versa
("Development of the seven foundational term types" below).)

To parse positional arguments (or "positionals") we must keep track of which
formal parameters we have parsed already and which we are expecting next at
each step. Each next *actual* parameter gets lined up and stiched together to
a *formal* parameter. (For more on this, see
"How we use stacks to parse positional parameters" below.)

In contrast to positionals, the two kinds of nonpositionals
(`optional_nonpositional` and `flag` (introduced below)) may (begin to) match
an actual token at (theoretically) any point in the ARGV stream. This is why
we conceive of the formal nonpositionals as a "floating cloud" that travels
along with us as we parse the ARGV. (See
"How we parse the nonpositionals with a floating cloud" below for more.)

Indeed, from an implementation perspective, in our engine we effectively
manage these two concerns "in parallel" and "orthogonally"; that is, what's
happening over on the one side doesn't really effect the other and vice versa.

With these two broad categories of formal parameter in mind, we can now
dive in to the seven particular term types our engine works with:


# Development of the seven foundational term types

To create the foundation of our CLI syntax "theory"; we see what happens when
we permute several characteristics across each other. Imagine this initial set
of characteristics:
- Whether the formal field is "required" or "optional"
- Whether it is positional or nonpositional ("opt" vs "arg")
- Whether the field invocation can occur multiple-ly in one invocation
  (e.g. "glob"; e.g. a "flag" where the magnitude increases with repetition)
- If nonpositional, whether the field takes a value (or is just a "flag")

One way to arrive at six of our foundational seven (#here1) term types is to
permute these four binary characterics across each other:

         [non]pos | req/opt  |   many? |  value? | nonterminal name
       positional | required |  exac 1 |     n/a | required_positional
       positional | optional |  0 or 1 |     n/a | nested_optional_positionals
       positional | required |  1-many |     n/a | required_glob
       positional | optional |  0-many |     n/a | optional_glob
    nonpositional | required |    meh  |     yes | [not yet implemeted]
    nonpositional | optional |  maybe  |     yes | optional_nonpositional
    nonpositional | optional |  maybe  |      no | flag

(:#here1: The seventh foundational term type is "subcommand"; which in
practice we implement as a `required_positional` with a value constraint on it.
Because it's a higher-level language phenomenon that can be derived from these
lower-level concepts, we won't consider it explicitly after this point; but keep
in mind it's a relevant distinction to the engine.)

Above shows seven rows. There should be 2^4 or sixteen rows. Why we don't
bother showing the missing nine rows is explored now:

Consider that our four categories are not cleanly orthogonal to each other in
practice: being "positional" implies "takes a value". So we could instead model
these two characteristics as a single taxonomy with three leaf nodes. As such
we'll munge "value?" and "[non]pos" together to make an ENUM-style field with
three possible values: `(positional, nonpos no value, nonpos takes value)`.

Furthermore a lower arity boundary (floor) of 0 implies "optional" and 1
implies "required". (We could just as well state this in the other direction:
"optional" implies a lower bounds of 0 and so on.) As such we'll simplify the
way we write the arities to simply "many" & "one". (We could just as soon
combine these two characteristics (optionality and many?) into a single enum
characteristic: `(0_1, 0_many, 1_1, 1_many)`; but we opt not to because of how
idiomatic, universal & understood is the concept of optionality
("required-ness") as its own characteristic.)

Let's now permute-out all these characteristics at this new moment,
with our revised 3 characteristics (this time 2x3x2 (12) permutations):

    required         positional            one   required_positional
    required         positional           many   required_glob
    optional         positional            one   nested_optional_positionals
    optional         positional           many   optional_glob

    optional     nonpositional no value    one   flag (but see #here2)
    optional     nonpositional no value   many   flag (but see #here2)
    required     nonpositional no value    one   flag (but see #here3)
    required     nonpositional no value   many   flag (but see #here3)

    optional   nonpositional takes value   one   optional_nonpositional (#here4)
    optional   nonpositional takes value  many   optional_nonpositional (#here4)
    required   nonpositional takes value   one   optional_nonpositional (#here5)
    required   nonpositional takes value  many   opt. nonpos. (#here4 & #here5)

Now notice all these footnote explanations this table requires:

:#here2: To have an arity characteristic on a flag is not "meta-syntactic":
In the wild, we *do* occasionally see a flag that is meaningfully "polyadic";
that is, that it is meaningful to repeat it (like see the "-v" option of the
python executable); however such a category of permutations is not modeled in
the "meta-syntax" (the syntax for parsing syntaxes); that is, we do not give
special representation in usage lines for those flags that can be meaningfully
repeated (just heuristically). We could (somehow) but we don't; because we've
never see it anywhere else; and we assume it happens not frequently enough for
it to be a formal language feature.

:#here3: Making a flag "required" is again a somewhat contrived permutation:
Almost axiomatically (if not tautologically), options are optional. To make an
option be required requires a leap of imagination: the '--force' (or '-f') flag
is sometimes required in some CLI operations; but again this is not a
meta-syntactic permutation: Our grammar for representing grammars does not have
any language features for modeling this permuation. We could but we don't
because it's a) not something we see in the wild and b) (relatedly) it's needed
so infrequently.

:#here4: The arity of a value-taking nonpositional is certainly interesting,
important and relevant; but FOR NOW it is not meta-syntactic: whether the
field acts like a list or a slot, this characteristic has no impact on how it
appears in usage lines. (It could, but it just doesn't because we haven't ever
seen this feature be expressed in any other usage lines elsewhere.)

:#here5: Similar to the perverse idea of a #here3 "required flag"; making a
required value-taking nonpositional is contrived. We have once in our life had
a use-case for this (a CLI for entering a database table row; the syntax
accepted option-looking name-value pairs; some columns were required) but again
this is certainly not meta-syntactic.

We can summarize the above footnotes to this: optionality and arity do not
meta-syntactically intersect with nonpositionals: you can have nonpositionals
with strange arities ("many") or strange optionalities ("required"); but these
contrived permutations do not get special recognition in the syntax for parsing
syntaxes. As such, we can simplify our permutations table down to this, most
practical distillation (which is not really one table but two (1x2x2 + 1x2)):

      positional required one        required_positional
      positional required many       required_glob
      positional optional one        nested_optional_positionals
      positional optional many       optional_glob
    nonpositional takes one value    optional_nonpositional
    nonpositional takes no value     flag

Again we do not develop the `subcommand` (macro) type through this approach
because it's above the scope of this methedology; but it bears keeping in mind
that it's the seventh term type.


# The order in which term types are processed

In review, here's the seven term types (expressed in plural because it
sounds more natural here):

- `subcommand`s
- `nonpositional`s (`flag`s and `optional_nonpositional`s)
- `required_positional`s
- `optional_positional`s (on surface, `nested_optional_positionals`)
- `required_glob` or `optional_glob` (mutually exclusive)

The above list also expresses the theoretical (if not also practical)
_order_ we want to process these formals in (both when processing actuals,
_and_ when producing lists of formals). Here's an explanation for each position:

`subcommand`s first: Intuitively, we do not know which commmand we are parsing
for until we know which command we .. are .. parsing for. So it follows that
we should parse for any subcommand first, before even parsing for
nonpositionals (but see discussion below on this).

`nonpositionals` before anything else (except subcommands): Pursuant to the
idea of a "floating cloud" of nonpositionals, ready to match an actual
nonpositional anywhere in the ARGV (see below); it follows that we should
parse (and represent) the nonpositionals first before the remaining
(positional) term types.

`required_positional`s before `optional_positional`s: It's possible to develop
parsers that "stitch" formals to actuals right-to-left rather than
left-to-right (see below near "stitching") (indeed some relatively recent
programming language versions allow this in their function signatures) BUT we
are not interested in such grammars at this time, because we don't recall
EVER seeing such a CLI grammar (optional positionals on the left) in the wild
_ever_; and to make such a feature opt-in would weigh-down our API without a
sufficient cost-benefit.

globs at the end: again we could make syntaxes that are left-globby rather
than right-globby; but we never see this in the wild. In practice, all the
CLIs we have ever seen that have a glob term have them as the finalmost
(rightmost) formal term of the syntax. We revist globs again in this section
below.

Multiple `optional_positional`s must nest: This is an interesting, derived
property of `optional_positional`s that should influence your syntax design:

Each next `optional_nonpositional` must piggy-back on any previous one.
To understand this, consider how the below nonsensical example of a syntax
is invalid:

    usage: {{prog_name}} [A] [B] [C]

The above suggests there could be an invocation where you only pass a value
for 'C' (but not 'A' or 'B') and so on. But, if only one actual positional
value is passed to the parser, how is it to know whether it "lines up with"
A, B, or C?

Rather, the closest you can come is:

    usage: {{prog_name}} [A [B [C]]]

But note this means that any invocation which passes a 'C' value must
also pass one for 'A' and 'B' and so on. In practice there are few command
interfaces that should want to align to such a constraint to any level of
depth past say 1 or 2, which is why if you find yourself wanting to use
three or more `optional_positional`s, you should probably use
`optional_nonpositional`s instead.

Now, there's an interesting interaction between the above language feature
of `nested_optional_positionals` and globs. First of all, it's possible to
have both in one syntax:

    usage: {{prog_name}} [A [B [C [D [D [..]]]]]]

The above says, "you can optionally pass an A (and optionally a B
(and then optionally a C (and any number of additional arguments, which
will be stored in the list "D")))".

Unfortunately, as we write this we realize that although it is possible to
produce a parser with the above grammar, the above syntax will not parse as
written. Rather, to get the above grammar you would have to write it like this
(even though the impossible syntax it suggests is not what it makes):

    usage: {{prog_name}} [A [B [C]]] [D [D [..]]]

The interesting interplay IS, you can have `optional_positional`s AND
globs so long as it's a `optional_glob` not a `required_glob`: I can't explain
why but having a required glob nullifies the ability for anything to be
positional and optional to its left.

But anyway, the uptake is, the seven types of terms are processed in this
order (theoretically when not also practically); for the reasons offered above.


# How we use stacks to parse positional parameters

We have written many argument parsers "by hand" that manage parsing
for one or more positional parameters. (The below table will capture
those CLIs that were once written by hand that now use "the engine".
You can look at each file and look for a history marker that can show
you the commit where they were changed from "by hand" to "engine-based"
to see what the code looked like when we wrote these parsers by hand.)

|       sub-project | identifier |  number of CLIs  |
|          kiss-rdb |  [#857.13] |  2 at writing    |


Having written so many by hand, we have
developed a favorite way to do so: represent these formal positionals (somehow)
on a stack, with each next positional that is expected being each next frame
on the stack.

    with each next token on the ARGV (frequently also turned in to a stack):
        if there's still more on the formal stack,
            pop the formal item off and use it to store the ARGV token,
            associating the token value with the name attached to the formal.
        otherwise (and the formal stack is now empty),
            fail with "unexpected argument: (etc)"

    (now that we exhausted ARGV)
    if there's still more on the formal stack,
        fail with "expecting (etc, formal argument name)"

We can implement trailing optional positionals by adding a boolean property to
the frames of the formal stack, and checking for this boolean value at the
final `if` clause above.

We can implement globs by adding yet another boolean property to the formal
structure and checking for it before we `pop` (and not popping off if it's
a glob.)

To implement these above two meta-properties correctly we will have to assert
that their particpating frames (formals) are in a sensical position relative
to one another (i.e at the end of the line of formals, or the bottom of the
stack.)


# How we parse the nonpositionals with a floating cloud

In the generated parser, we (by default, and at writing always) parse
"nonpositionals" in what we consider to be the "least surprise", commonmost
way; where they can occur alsmot anywhere vis-a-vis the positionals. (We will
put a finer point on this later in this section).

We *could* generate parsers that follow to the letter the positionality
suggested by the usage line; that is, imagine the syntax suggested by:

    usage: {{prog_name}} [--flag1] [--opt-nonpos1=X] ARG1 [-x] [-y] ARG2

Is it that the `-x` and `-y` flags are recognized only between the actual
tokens for ARG1 and ARG2? We think not. In practice, we see it as a commonly
understood idiom that nonpositionals can occur before, after, or in the
middle of the run of positionals.

This is why in the implementation of the engine we refer to this as a
"floating cloud" of formal nonpositionals: the "cloud" of possible
nonpositionals "floats along" the parsing of the ARGV.

This is in stark contrast to the stack-like parsing of positionals,
where where (sic) you are in the ARGV has a big impact on whether and how
each next positional-looking token is parsed.

It's worth mentioning that in the above, we are talking about where the
_actual_ parameters (ARGV tokens) may fall; not how the _formal_ parameters
are placed with respect to each other in (say) the usage line. The above
section "The order in which term types are processed" suggests a formal order
for the frontend to follow; but officially this is up to the frontend what
surface order they want their terms to be in.

Now, interestingly this can be true or not true when it comes to
nonpositionals vis-a-vis the chain of subcommand literals. What we imagine
to be the "least surprise" way would be that you can't start using
nonpositionals until you know what subcommand is invoked (because each
subcommand has its own associated nonpositonals (and positionals).

Remarkably, the above constraint would not necessarily have to be so:
XX we won't bother explaining this until we have a test demonstrating the
idea (that there's no reason you can't start parsing for a subcommand's
nonpositionals before parsing the subcommand literals -- except that it
could lead to messy fail states if you have subcommands that assign different
constraints or syntactic categories to the same surface names...)


# "BSD-style" nonpositionals

We refer to this "mode" of parsing as "BSD-style" because we first noticed
it in our `find` utility which happeed to come from BSD (although this "mode"
is also at play in the GNU variant of `find`).

By this mode we mean simply that there is no separate "short" surface form
for nonpositionals, and that every nonpositional "familiar name" uses exactly
one dash and never two (except we will probably continue to parse `--help`
with two in addition to one dash).

We will either discourage or more likely proscribe that this is all-or-nothing:
if you want BSD-style names for some of your nonpositionals, they must all
follow suit. 

It is the syntax designer's choice which mode to employ.




## (document-meta)

- #born
