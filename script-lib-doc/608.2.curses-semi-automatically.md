# Objective & Scope

- experiment in semi-generated interfaces (revisiting an old flame)
- we will want something like this for our "data explorer" thing
- the grand innovation of semi-isomorphic interfacing
- curses for the thrill of curses



# Overview of imagined premises

- Interfaces can be represented abstractly as treelike structures, starting
  from the root of the application (the whole thing) to every little checkbox
- So the theory goes (and the theory seems sound), a sufficiently detailed
  abstract representation of an interface can be used to generate *entirely*
  an 80% good-enough actual interface for any variety of "modalities":
  non-interactive CLI ("niCLI"), non-curses interatactive CLI, curses, web,
  GUI, watch, NLP AI, etc.
- (However, our scope will not be to prove this for all modalities or even
  any; our scope is to 1) experiment with rolling out such an AST and start
  to feel what it feels like 2) see how far we can get with producing an actual
  ncurses interface automatically from the niCLI [sl] "cheap arg parse"
  formals structure. We believe we should be able to accomplish this.)



# Imagined vocabulary and key principles

                  +-------------------------------------
    top row: nav: |      [..] foo > bar > baz
                  +-------------------------------------
                  |          some field:  Foo bar baz
    middle area   |       some checkbox:  [ ]
    form fields   |      some poly opts:
    splay:        |              [name]:  [value]
                  |
                  |-------------------------------------
    context-sens  |
    action        |
    "buttons"     |   [s]end  [b]ack  [q]uit
                  +-------------------------------------


- Up and Down arrows go up and down the selectable components ("selectables")
- The context-sensitive action buttons change
- Some remain fixed like the bottom row (but may become unelectable)
- To keep things simple in one way and make them complicated in another,
  there will be "inbound constraints"



# Quick summary of candidates for reserved hotkeys (rough sketch)

- [b]ack
- [c]ancel (might swap in for [b]ack)
- [d]one (like back)
- [e]xit (reserved)
- [q]uit
- [s]{end/ubmit}



# Types of selectable and their interface interactions

Abbreviations used here:

- dwa: disallowed when appropriate


Emerging key concepts:

(EDIT: the next two paragraphs contradict)

There isn't a hard concept of "selected". Each "selectable" component has a
concept of an "initial state" and it receives soft events like "mouse over"
and "mouse leave", or relevant buttons pressed. It changes its own state
as a response to these events; and state changes result in different visual
representation and different buttons available.

However, there *is* a sort of implicit idea of "selected" because only
one component at any given time can change the display of available
hotkeys (and also, the available hotkeys (buttons))


The selectables:

- Top row nav
  - hmm
- Plain old field
  - when mouse over:
    - [enter] for edit
  - when editing:
    - [whatever this emacs thing is]
- Checkbox (i.e from flag):
  - when mouse over:
    - [enter] to toggle
- Poly opts (label):
  - when mouse over:
    - [a]dd (inserts item at top, selects, enters edit mode)
- Poly option (item):
  - when mouse over:
    - [enter] to edit
    - [d]elete (confirms with a [y]es/[c]ancel)
    - move item [u]p
    - move item [d]own
  - when entered:
    - [left arrow] mouse over name (DWA)
    - [right arrow] mouse over value (DWA)
  - when mouse over name
    - [enter] to edit name
  - when mouse over value
    - [enter] to edit value
  - when editing name: emacs thing
  - when editing value: emacs thing


We are attempting to draw up a state machine for each of these [#HERE]



# Inappropriately adaptive UI:

Every component with a visual representation (so, all of them) must be able
to report its minimum required height and width. Branch components do the
necessary addition of the metrics of their child components (and this
happens recursively) to determine their own size constraints. (And note that
some branch components may have to do additional cleverness with how they
manage outlines they have to draw..)

We can pre-calculate the constraints of the interface before we even enter
screen mode; but we can't know the current dimensions of the screen until
once we are in screen mode. If we enter screen mode and see that the screen
is too small (in one or both dimensions) for our interface, we want to exit
with a detailed error message explaining the necessary dimension(s).

Now, an immutability must be followed for this to keep making sense and
working: properties that effect the constraints of components must be
immutable for the lifetime of the component; so, if a field component's
width constraint is informed by its label text, the label text can't change
for any given field ever (without some clever programming that follows
these principles), and so on. (But keep reading..)



## Weirdly :[#608.2.B]

Weirdly (and experimentally), we are going to allow that some UI behavior can
be informed by arbitrary screen metrics:

If a text field doesn't explicity model its own *maximum* string value length,
this constraint can be informed by the on-screen metrics: A screen that is
wider can allow for wider text field value strings.

We are imagining this provision because it's what ~feels~ most intuitive and
obvious; but it presents some gotchas: if you "edit a model" of a thing when
your screen is at some certain wide width; you exit the interface, and size
your screen down to narrower, then you try to edit the same model; the
interface could fail to open because it can't meet the size constraints of
the model!

(The curses idea of a `pad` seems designed to solve problems like these,
but we want to avoid interfaces that require paging up / paging down etc,
(or a CSS-like idea of "overflow") as long as we can.)

This same dynamic will affect growable lists in both directions: How many
items can be added to a growable list will be informed by how high the
screen is. The constraint of vertical height for the interface will be
informed by how many items are in growable lists.



## But you said immutable

Yes, properties that effect the dimensions *can* change; but we must make
sure they change according to the *maximum* constraints in those dimensions
(the available space). In theory this same principle could apply if you really
wanted a field whose label you changed dynamically.



# Other features:

In the same spirit that there is an "isomorphism" between corresponding
interfaces in niCLI and ncurses, we want to explore the isomorphisms between
"requests" on both sides.

Put another way, we want to see what it is like to use the ncurses interface
to (in effect) *edit* a command line buffer.

The purpose of this isn't just pure novelty; it's so we can (in effect) save
the state of complicated forms and reproduce them easily during development.

There is a chance also that such an isomorphism could be leveraged internally
for sending requests; but we'd rather avoid that architecture; opting instead
for the way niCLI does things with `vals`.



# (document-meta)

  - #born
