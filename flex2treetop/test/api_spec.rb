require_relative 'my-test-support'

module Skylab::Flex2Treetop::MyTestSupport

  describe "[f2] API" do

    extend Top_TS_

    use :want_event
    use :want_line

      it "load" do

        Home_::API
      end

      it "ping" do

        call_API :ping, :arg_1, :_x_

        want_neutral_event :ping, 'helo:(_x_)'
        want_no_more_events
        expect( @result ).to eql :_cheeky_monkey_
      end

      it "u-nrecognized action" do

        call_API :wiggle, :you_never, :see_these, :args

        want_not_OK_event :no_such_action do  | ev |

          expect( ev.action_name ).to eql :wiggle
        end
        want_fail
      end

      it "version" do

        call_API :version

        expect( @result ).to match(
          %r(\A#{ ::Regexp.escape REAL_PROGNAME_ }: \d+(?:\.\d+)*\z) )
      end

      it "bare version" do

        call_API :version, :bare

        expect( @result ).to match %r(\A\d+(?:\.\d+)*\z)
      end

      it "reflect tests" do

        call_API :test, :list
        st = @result
        test = st.gets
        expect( test.basename_string ).to eql 'fixthis.flex'
      end

      it "infile not exist" do

        call_API :translate,
          :flex_file, tmpdir_instance.join( 'not-there.flex' ).to_path,
          :resources, Mock_resources_[],
          * _outpath_arg( '_no_see_' )

        want_not_OK_event_ :errno_enoent,
          %r(\bNo such \(par flex_file\) - \(pth ".+not-there\.flex"\)\z)

        want_fail
      end

      it "infile not file" do

        call_API :translate,
          :flex_file, FIXTURE_FILES_DIR_,
          :resources, Mock_resources_[],
          * _outpath_arg( '_meh_' )

        em = want_not_OK_event :wrong_ftype

        expect( black_and_white( em.cached_event_value ) ).to match(
          %r(\A«[^»]+/fixture-files» exists but is not a file, it is a directory\b) )

        want_fail
      end

      it "infile exist, outfile exist and force not present" do

        call_API :translate, * _etc( _file_with_some_content )

        _em = want_not_OK_event_ :missing_required_permission

        expect( black_and_white( _em.cached_event_value ) ).to match(
          %r(\A'output-path' exists, won't overwrite without 'force': #{
            }«[^»]+file-with-some-content) )

        want_fail
      end

      it "infile exist, outfile not file" do

        _in_path = _file_with_some_content

        _out_path = FIXTURE_FILES_DIR_

        call_API :translate, :force, :flex_file, _in_path, * _etc( _out_path )

        _em = want_not_OK_event_ :errno_eisdir

        _rx = %r(\AIs a directory - «.+/fixture-files)

        expect( black_and_white( _em.cached_event_value ) ).to match _rx

        want_fail
      end

      it "minimal case" do

        _init_outpath

        call_API :translate, * _etc

        _prepare_to_verify_content

        __want_first_few_lines

        __want_last_few_lines
      end

      def __want_first_few_lines

        expect( next_line ).to match %r(\A# Autogenerated by flex2tree)

        _skip_blanks_and_comments

        expect( line ).to eql "rule escape__of_lexer__\n"
      end

      def __want_last_few_lines

        scn = @want_line_scanner

        exp_a = <<-'HERE'.unindent.split %r((?<=\n))
          rule ignore_comments
            "\/" "\*" [^*]* "\*"+ ([^/*] [^*]* "\*"+)* "\/"
          end
        HERE

        scn.advance_to_before_Nth_last_line exp_a.length

        exp_a.each do | want_line |

          expect( scn.next_line ).to eql want_line
        end
      end

      it "wrap in one grammar module" do

        _init_outpath

        call_API :translate, :wrap_in_grammar, "Danbury", * _etc

        _prepare_to_verify_content

        _skip_blanks_and_comments

        expect( line ).to eql "grammar Danbury\n"

        _count = @want_line_scanner.skip_lines_that_match(

          /\A[ ]{2,}[^[:space:]]|\A\n\z/ )

        expect( _count ).to eql 20

        expect( line ).to eql "end\n"
      end

      it "wrap in two grammar modules" do

        _init_outpath

        call_API :translate, :wrap_in_grammar, "Fibble::Toppel", * _etc

        _prepare_to_verify_content

        _skip_blanks_and_comments

        expect( line ).to eql "module Fibble\n"
        expect( next_line ).to eql "  grammar Toppel\n"
        expect( next_line ).to eql NEWLINE_
        expect( next_line ).to eql "    # from flex name definitions\n"
      end

      def _prepare_to_verify_content

        :translated == @result or fail

        want_neutral_event :before_probably_creating_new_file
        want_neutral_event :cant_deduce_rule
        want_no_more_events

        @output_s = ::File.read @outpath
        NIL_
      end

      it "bad grammar name" do

        _init_outpath

        call_API :translate, :wrap_in_grammar, 'Doonesbury Cartoon', * _etc

        :translate_failure == @result or fail

        want_neutral_event :before_probably_creating_new_file

        _em = want_not_OK_event :invalid_NS

        expect( black_and_white( _em.cached_event_value ) ).to eql(

          "grammar namespaces look like \"Foo::BarBaz\". #{
            }this is not a valid grammar namespace: \"Doonesbury Cartoon\"" )

        want_no_more_events

        expect( ::File.read( @outpath ) ).to match( /\A# Auto[^\n]+\n\z/ )
      end

      it "option - show sexp (it's a big dump)" do

        g = TestSupport_::IO.spy.group.new

        g.do_debug_proc = -> do
          do_debug
        end

        g.debug_IO = debug_IO
        io = g.add_stream :A

        @resources = Mock_Resources_.new nil, nil, io

        _init_outpath  # we will assert that it is not created

        call_API :translate, :show_sexp_only, * _etc

        :showed_sexp == @result or fail

        ::File.exist?( @outpath ) and fail

        @line_stream_for_want_line = g.flush_to_line_stream_on :A

        expect( next_line ).to eql "[:file,\n"

        scn = @want_line_scanner

        _count = scn.skip_until_before_Nth_last_line 1
        expect( _count ).to eql 59

        expect( scn.next_line ).to match(

          %r(\A {2,} :action=>\[:action, "return \*yytext;) )

        expect( scn.next_line ).to be_nil
      end

      it "parser from FS - nosaj thing - x" do

        _init_outpath  # we will assert that it is not created

        _path = ::File.join FIXTURE_FILES_DIR_, 'not-a-dir'

        _API_invoke_with_parser_dir _path

        :parser_dir_not_exist == @result or fail

        ::File.exist?( @outpath ) and fail

        want_not_OK_event :enoent,
          %r(\ANo such file or directory #{ ICK_ }- [^ ]+/not-a-dir\z)

        want_no_more_events
      end

      it "parser from FS - saj thing - OK", alone: true do

        # NOTE - sadly this is not a test-friendly scenario: the designed
        # behavior is different based on whether or not grammars have been
        # loaded already. as such, the below conditionally covers whether
        # this test is run alone (or perhaps first), and whether it is run
        # after cases that will have loaded the gramars already.

        _init_outpath  # we will assert that it is not created

        _path = tmpdir_instance.touch_r( 'a-dir/' ).to_path

        _API_invoke_with_parser_dir _path

        want_neutral_event :wrote_grammar
        want_neutral_event :writing_compiled
        want_neutral_event :wrote_compiled

        if :filesystem_touched == @result
          __single_case
        else
          __group_case
        end

        want_no_more_events
      end

      def __single_case

        want_neutral_event :touched
      end

      def __group_case

        :cannot_use_FS_flex_file_parser_already_loaded == @result or fail
        want_not_OK_event :ff_parser_already
      end

      def _API_invoke_with_parser_dir x

        call_API :translate,

          :use_FS_parser, :FS_parser_dir, x, :endpoint_is_FS_parser, * _etc
      end

      def _etc x=@outpath
        [ :resources, ( resources || Mock_resources_[] ),
          :flex_file, fixture_flex_( :mini ),
          :output_path, x ]
      end

      attr_reader :resources

      def _outpath_arg s
        [ :output_path, s ]
      end

      def _file_with_some_content

        fixture_file_ 'file-with-some-content', :txt
      end

      def _init_outpath

        td = self.tmpdir_instance
        td.prepare  # nuke any old files from before
        @outpath = td.join( 'o.rb' ).to_path
        NIL_
      end

      def _skip_blanks_and_comments

        want_line_scanner.advance_past_lines_that_match %r(\A(?:#|$))

        NIL_
      end

      def subject_API_value_of_failure
        FALSE
      end

      def subject_API
        Home_::API
      end
  end
end
