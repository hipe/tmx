#!/usr/bin/env ruby -w

if (( idx = ::ARGV.index '--coverage' ))
  require_relative 'plugins/coverage/manager'  # see comments here
  ok, res = ::Skylab::Test::Plugins::Coverage::Manager.instance.start(
    ::Enumerator::Yielder.new { |m| $stderr.puts m }, ::ARGV, idx )
  ok or exit res
end

require_relative '../lib/skylab'
require 'skylab/face/core'      # `pretty_path`, Tableize::I_M
require 'skylab/test-support/core'  # headless plugin API, `_spec_rb`
require 'optparse'

module Skylab::Test

  %i| Face Headless MetaHell Test |.each do |i|
    const_set i, ::Skylab.const_get( i, false )
  end

  extend MetaHell::MAARS

  module Plugins
    extend MetaHell::MAARS  # only necessary b.c of coverage mgr
  end

  class Core_Client  # a "headless" client, conceptually

    Headless::Plugin::Host.enhance self do
      add_plugins_box_module Test::Plugins
      eventpoints %i|
        available_actions
        action_summaries
        available_options
        default_action
        argv_hijinx
        argument_list
        ready
        subtree
        conclude
      |
      service_names %i|
        em
        full_name
        full_program_name
        info_y
        infostream
        paystream
        pretty_path
        run_mode
      |
      services_delegated_to :subtree, %i|
        hot_spec_paths
        hot_subtree
      |
    end

  private

    def initialize
      @queue_a = []
    end

    # `full_name` - a service provided by this host

    def full_name
      self.class.full_name
    end

    def self.full_name
      #  program_name   # why do this when you could ..
      @full_name ||= ::Pathname.new( __FILE__ ).expand_path.relative_path_from(
        ::Skylab.dir_pathname.dirname.dirname ).to_s
    end
  end

  module Host_InstanceMethods  # (re-opened below)
  end

  class CLI < Core_Client  # (separation of concerns)

    include Host_InstanceMethods

    def initialize _, sout, serr
      super( )
      @action_a = nil
      @emit = -> type, str do
        ( :payload == type  ? sout : serr ).puts str
      end
      @paystream, @infostream = sout, serr
      @info_y = ::Enumerator::Yielder.new do |message_string|
        @infostream.puts message_string
      end
      @em = -> s { "\e[1;32m#{ s }\e[0m" }
      @pretty_path = Headless::CLI::PathTools::FUN.pretty_path
      nil
    end

    def invoke argv
      begin
        load_plugin_modules
        Ingest_Hack_[ self ]
        @argv = argv
        r = resolve_queue or break
        r = ready or break
        while tok = @queue_a.shift  # not using reduce b.c 1 stack frame
          action = action_a.detect { |a| a.normalized_local_name == tok }
          if action
            plugin_validate_client action.client
            r = action.client.send action.as_method
            if false == r
              break  # meh
            else
              emit_eventpoint_to_each_client :conclude do |client|
                ::Enumerator::Yielder.new do |msg|
                  @info_y << "(#{ client.plugin_slug } plugin #{ msg })"
                  nil
                end
              end
            end
          else
            send tok  # e.g 'help'
          end
        end
      end while nil
      r
    end

  private

    def load_plugin_modules
      ::Dir[ "#{ Test::Plugins.dir_pathname }/*.rb" ].each do |path|
        require path
      end
      nil
    end

    def emit type, data
      @emit[ type, data ]
    end

    def help
      info option_parser.banner
      option_parser.summarize { |s| info s }
    end

    def info msg
      emit :info, msg
      nil
    end

    # (the below group is services. doing it this way and not with
    # `attr_reader` creates good warnings and avoids dumb ones.)

    def info_y     ; @info_y end
    def infostream ; @infostream end
    def paystream  ; @paystream end
    def em  s      ; @em[ s ] end

    def option_parser
      @option_parser ||= build_option_parser
    end

    def parse_opts
      option_parser.parse! @argv
      true
    rescue ::OptionParser::ParseError => e
      usage e
    end

    def program_name
      @option_parser.program_name
    end

    def usage msg
      emit :error, msg
      info usage_line
      info "See #{ em "#{ program_name } -h" } for more help."
      false
    end

    def usage_line
      "#{ em 'Usage:' } #{ option_parser.program_name } [opts] #{
        }[[#{ action_names * '|' }] [..]] [subproduct [subproduct [..]]]"
    end

    def ready

      ok = true

      f = -> client do
        ::Enumerator::Yielder.new do |msg|
          ok = false
          @info_y << "#{ client.plugin_slug } #{ msg }"
        end
      end

      emit_eventpoint_to_each_client :ready, & f

      emit_eventpoint_to_each_client :subtree, & f

      if ok then ok else
        @info_y << "won't procede further because of the above."
        false
      end
    end

    # `resolve_queue` - test/all is expected to be run for at least two
    # purposes - 1) it is a file we can load with `rspec` and have it load
    # "every" spec file in our universe.  2) it is an executable we can run
    # standalone utilizing several options, including but not limited to
    # invoking `rspec` *while* having warnings turned on on our tests.
    # `run_mode` exists to determine and represent that distinction.

    # NOTE - it bears pointing out that the grammar for this utility is
    # ambiguous. it draws symbols from both the set of available action names
    # and the set of existing subproduct names, such that how your command is
    # interpreted will depend on both of these at the time it is run, with
    # tokens you intend as subproduct names possibly getting masked by (and
    # interpreted as) action names.
    #
    # there is no solution yet implemented for this problem (for whenever there
    # exists as an input token a token that looks like an action name that
    # action will be popped off the input stream and added to the action queue
    # as long as such tokens exist at the front of the input stream), but at
    # present the problem is not a problem because there is no set union between
    # the exponents of the two namespaces, (that is, there is no name that is
    # shared by both action and subproduct name) hence the grammar is de-facto
    # unambiguous, but only by sheer dumb luck.
    #
    # the solution (if ever needed) will likely be adding the one line of code
    # necessary to let "--" separate these two nonterminal symbols.

    def resolve_queue
      ok = true
      begin
        if :cli == run_mode
          parse_opts or break
          parse_any_explicit_actions_off_of_argv or break
        end
        resolve_default_action_if_necessary or break
        if :cli == @run_mode && @argv.length.nonzero?
          emit_eventpoint :argv_hijinx, @queue_a.fetch( 0 ), @argv
          emit_eventpoint :argument_list, @argv if @argv.length.nonzero?
          if @argv.length.nonzero?
            @info_y << "won't run with un argv - #{ @argv }"
            ok = false
          end
        end
      end while nil
      ok && @queue_a.length.nonzero?
    end

    # `run_mode` - see notes at `resolve_queue`.
    # result is { :cli | :rspec | :none }

    def run_mode  # - service
      @run_mode ||= if __FILE__ == $PROGRAM_NAME then :cli
        elsif %r{/rspec$} =~ $PROGRAM_NAME then :rspec  # ick
        else :none end
    end

    # (called by the framework from `parse_opts`)

    def build_option_parser
      @option_parser = o = ::OptionParser.new
      o.banner = usage_line
      o.separator(
        "#{em 'Description:'} runs all known tests in the skylab universe.")

      h = { }
      emit_eventpoint :action_summaries do |ea|
        ea.each do |hash|
          h.merge! hash
        end
      end

      max = 0
      pair_a = action_a.reduce [] do |m, act|
        act.slug.length > max and max = act.slug.length
        m << [ act.slug, ( h.fetch( act.norm ) do
          "the #{ em act.slug } action"
        end ) ]
        m
      end

      fmt = "    %-#{ max }s    %s"
      a = pair_a.reduce [] do |m, (one, two)|
        m << fmt % [ one, two ]
      end
      o.separator "#{ em 'Actions:' }\n#{ a * "\n" }"

      o.separator "#{ em 'Options:' }"

      merge_options o, -> merger do
        merger.add(Headless::CLI::Option.on( '-h', '--help', 'this screen.' ) do
          @queue_a << :help
        end )  # when we add self, we've got to define `plugin_slug`
      end

      o
    end

    def full_program_name
      $PROGRAM_NAME
    end

    def plugin_slug  # - because we add self to merged o.p
      program_name
    end

    def action_names
      @action_names ||= action_a.map( & :slug )
    end

    # `action_a` - this is where we aggregate and sort the action metadata
    # from all our plugins and line it up into a neat little row (note it
    # is in a determinsistic way, to boot).

    def action_a
      if ! @action_a
        emit_eventpoint :available_actions do |ea|
          @action_a = plugin_flatten_and_sort ea, Action_
        end
        @action_a ||= [ ]
      end
      @action_a
    end

    Action_ = ::Struct.new :normalized_local_name, :client, :priority
    class Action_
      alias_method :norm, :normalized_local_name
      def slug
        @slug ||= normalized_local_name.to_s  # important
      end
      def as_method
        @as_method ||= slug.gsub( '-', '_' ).intern
      end
    end

    def parse_any_explicit_actions_off_of_argv
      while @argv.length.nonzero?
        tok = @argv.fetch 0
        rx = /\A#{ ::Regexp.escape tok }/i
        act = @action_a.detect { |a| rx =~ a.slug }
        if act
          @argv.shift  # (we lose the actual token used here.)
          @queue_a << act.norm
        else
          break
        end
      end
      true
    end

    def resolve_default_action_if_necessary
      if @queue_a.length.zero?  # could be shortened but meh
        nam = nil
        emit_eventpoint :default_action do |ea|
          wgt = 0.0
          nam = ea.reduce nil do |m, ((name, weight), _c) |
            if weight > wgt
              m, wgt = name, weight
            end
            m
          end
        end
        nam && @queue_a << nam
      end
      @queue_a.length.nonzero?
    end
  end

  module Host_InstanceMethods

    # because we are crazy and we have plugins with plugins ..

  private

    # `merge_options` - comprehend over all plugins and hack an
    # aggregate option parser.

    def merge_options up_op, at_end=nil, ctx_a=nil
      ep = plugin_manager.fetch_eventpoint :available_options  # (raises custm)
      merger = Headless::CLI::Option::Merger.new method( :qualified_plugin_slug)
      @plugin_manager.hot_plugins.each do |client|
        if client.plugin_subscribed? ep.name  # (as op to `c.plugin_eventpoint`)
          rec = Headless::CLI::Option::Parser::Recorder.new do |opt|
            merger.add opt, * [ * ctx_a, client ]
          end
          client.send ep.as_method_name, rec, ctx_a
        end
      end
      at_end and at_end[ merger ]
      merger.write up_op
      nil
    end

    # `qualified_plugin_slug` - this method (as a proc) is passed to the
    # option merger to tell it how to render the slug-like identifying
    # string for the plugin (a hacky view template). (the merger makes some
    # decisions on its own, like adding parenthesis, and putting the slug
    # string at the end and not the beginning of all the content)

    def qualified_plugin_slug * cx_a

      # the hacky way we get around desc lines qualifiying themselves
      # multiple times for the final desc line of a plugin that has plugins
      # (whew) is this (add a `true or` in there to see the difference):

      if ! cx_a.last.is_plugin_host
        a = cx_a.reduce [] do |m, client|
          m << client.plugin_slug
          m
        end
        "#{ a * ' ' } plugin"
      end
    end
  end

  Ingest_Hack_ = -> host do  # #todo:during:6
    host.instance_exec do
      plugin_manager.hot_plugins.each do |pi|
        h = pi.plugin_story.instance_variable_get( :@service_h )
        pi.plugin_story.services.each do |se|
          if ( svc = h.fetch( se ) ).do_ingest
            pi.instance_variable_set svc.ingest_to_ivar,
              ( instance_variable_get svc.ingest_to_ivar )
          end
        end
        pi.respond_to?( :_ingest_hack ) and pi._ingest_hack
      end
    end
    nil
  end
end

Skylab::Test::CLI.new( $stdin, $stdout, $stderr ).invoke ARGV
