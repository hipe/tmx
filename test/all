#!/usr/bin/env ruby -w

module Skylab  # hold on for a moment & let it get weird because of [#te-002]:

  require 'pathname'

  module Test

    LIB_SKYLAB_PN_ = -> do  # because we don't yet have ::Skylab.dir_pathname
      pn = nil
      -> do
        pn ||= ::Pathname.new( ::File.expand_path '../../lib/skylab', __FILE__ )
      end
    end.call

    FULL_NAME_ = -> do  # like `program_name` but normalized to an anchor
      fn = nil
      -> do
        fn ||= ::Pathname.new( __FILE__ ).expand_path.relative_path_from(
          LIB_SKYLAB_PN_[].dirname.dirname ).to_s
      end
    end.call

    module Plugins
      class Coverage  # we have to pay this back at #this-spot
        SWITCH_ = '--coverage'
        if (( idx = ::ARGV.index SWITCH_ ))
          require_relative 'plugins/coverage/manager'
          y = ::Enumerator::Yielder.new( & $stderr.method( :puts ) )
          ok, res = Manager.instance.start y, ::ARGV, idx
          if ! ok
            y << "see '#{ FULL_NAME_[] } --help'."
            exit res
          end
        end
      end
    end
  end
end  # OK now that coverage agent may have started, we can procede as normal:

require_relative 'core'
require 'optparse'

module Skylab::Test

  module Plugins
    MetaHell::Boxxy[ self ]
  end

  class Core_Client  # a "headless" client, conceptually

    Headless::Plugin::Host.enhance self do

      plugin_box_module -> { Test::Plugins }

      eventpoints( * %i|
        available_actions
        action_summaries
        available_options
        default_action
        argv_hijinx
        argument_list
        ready
        subtree
        conclude
      | )

      services [ :em, :ivar ],
        :full_name,
        :full_program_name,
        [ :hot_spec_paths, :delegatee, :subtree ],
        [ :hot_subtree, :delegatee, :subtree ],
        :info_y,
        :infostream,
        :paystream,
        [ :pretty_path, :ivar ],
        :run_mode,
        :get_expression_agent

    end

  private

    def initialize
      @queue_a = []
    end

    def full_name  # a service provided by this plugin host
      FULL_NAME_[]
    end
  end

  module Host_InstanceMethods  # (re-opened below)
  end

  class CLI < Core_Client  # (separation of concerns)

    include Host_InstanceMethods

    def initialize _, sout, serr
      super( )
      @action_a = nil
      @emit = -> type, str do
        ( :payload == type  ? sout : serr ).puts str
      end
      @paystream, @infostream = sout, serr
      @info_y = ::Enumerator::Yielder.new( & @infostream.method( :puts ) )
      @em = -> s { "\e[1;32m#{ s }\e[0m" }
      @pretty_path = Headless::CLI::PathTools::FUN.pretty_path
      nil
    end

    def determine_hot_plugins  # becuase we hackishly defined a node outside
      # of its "home file" in #this-spot, we now have to pay it back here:
      # "manually" load the file now for any such nodes (because of [#te-002])

      Test::Plugins.boxxy do
        original_constants.each do |i|
          load dir_pathname.join( pathify i ).sub_ext( extname ).to_s
          upwards get_const( i )
        end
      end

      super
    end

    def invoke argv
      begin
        @argv = argv
        r = resolve_queue or break
        r = ready or break
        while tok = @queue_a.shift  # not using reduce b.c 1 stack frame
          act = action_a.detect { |a| a.local_normal_name == tok }
          if act
            r = act.client.send act.as_method
            if false == r
              break  # meh
            else
              emit_customized_eventpoint :conclude, -> pi do
                [ ::Enumerator::Yielder.new do |msg|
                  @info_y << "(#{ pi.local_plugin_moniker }#{
                    } plugin #{ msg })"
                  nil
                end ]
              end
            end
          else
            send tok  # e.g 'help'
          end
        end
      end while nil
      r
    end

  private

    def emit type, data
      @emit[ type, data ]
    end

    def help
      info option_parser.banner
      option_parser.summarize { |s| info s }
    end

    def info msg
      emit :info, msg
      nil
    end

    # (the below group is services. doing it this way and not with
    # `attr_reader` creates good warnings and avoids dumb ones.)

    def info_y     ; @info_y end
    def infostream ; @infostream end
    def paystream  ; @paystream end
    def em  s      ; @em[ s ] end

    def option_parser
      @option_parser ||= build_option_parser
    end

    def parse_opts
      option_parser.parse! @argv
      true
    rescue ::OptionParser::ParseError => e
      usage e
    end

    def program_name
      @option_parser.program_name
    end

    def usage msg
      emit :error, msg
      info usage_line
      info "See #{ em "#{ program_name } -h" } for more help."
      false
    end

    def usage_line
      "#{ em 'Usage:' } #{ option_parser.program_name } [opts] #{
        }[[#{ action_names * '|' }] [..]] [subproduct [subproduct [..]]]"
    end

    def ready

      ok = true

      f = -> pi do
        [ ::Enumerator::Yielder.new do |msg|
          ok = false
          @info_y << "#{ pi.local_plugin_moniker } #{ msg }"
        end ]
      end
      emit_customized_eventpoint :ready, f
      emit_customized_eventpoint :subtree, f

      if ok then ok else
        @info_y << "won't procede further because of the above."
        false
      end
    end

    # `resolve_queue` - test/all is expected to be run for at least two
    # purposes - 1) it is a file we can load with `r-spec` and have it load
    # "every" spec file in our universe.  2) it is an executable we can run
    # standalone utilizing several options, including but not limited to
    # invoking `r-spec` *while* having warnings turned on on our tests.
    # `run_mode` exists to determine and represent that distinction.

    # NOTE - it bears pointing out that the grammar for this utility is
    # ambiguous. it draws symbols from both the set of available action names
    # and the set of existing subproduct names, such that how your command is
    # interpreted will depend on both of these at the time it is run, with
    # tokens you intend as subproduct names possibly getting masked by (and
    # interpreted as) action names.
    #
    # there is no solution yet implemented for this problem (for whenever there
    # exists as an input token a token that looks like an action name that
    # action will be popped off the input stream and added to the action queue
    # as long as such tokens exist at the front of the input stream), but at
    # present the problem is not a problem because there is no set union between
    # the exponents of the two namespaces, (that is, there is no name that is
    # shared by both action and subproduct name) hence the grammar is de-facto
    # unambiguous, but only by sheer dumb luck.
    #
    # the solution (if ever needed) will likely be adding the one line of code
    # necessary to let "--" separate these two nonterminal symbols.

    def resolve_queue
      ok = true
      begin
        if :cli == run_mode
          parse_opts or break
          parse_any_explicit_actions_off_of_argv or break
        end
        resolve_default_action_if_necessary or break
        if :cli == @run_mode && @argv.length.nonzero?
          emit_eventpoint :argv_hijinx, @queue_a.fetch( 0 ), @argv
          emit_eventpoint :argument_list, @argv if @argv.length.nonzero?
          if @argv.length.nonzero?
            @info_y << "won't run with un argv - #{ @argv }"
            ok = false
          end
        end
      end while nil
      ok && @queue_a.length.nonzero?
    end

    # `run_mode` - see notes at `resolve_queue`.
    # result is { :cli | :rspec | :none }

    def run_mode  # - service
      @run_mode ||= if __FILE__ == $PROGRAM_NAME then :cli
        elsif %r{/rspec$} =~ $PROGRAM_NAME then :rspec  # ick
        else :none end
    end

    # (called by the framework from `parse_opts`)

    def build_option_parser
      @option_parser = o = ::OptionParser.new
      o.banner = usage_line
      o.separator(
        "#{em 'Description:'} runs all known tests in the skylab universe.")

      desc_h = { }
      emit_eventpoint :action_summaries do |_pi, hh|
        desc_h.merge! hh
      end

      max = 0
      pair_a = action_a.reduce [] do |m, act|
        act.slug.length > max and max = act.slug.length
        m << [ act.slug, ( desc_h.fetch( act.local_normal_name ) do
          "the #{ em act.slug } action"
        end ) ]
        m
      end

      fmt = "    %-#{ max }s    %s"
      a = pair_a.reduce [] do |m, (one, two)|
        m << fmt % [ one, two ]
      end
      o.separator "#{ em 'Actions:' }\n#{ a * "\n" }"

      o.separator "#{ em 'Options:' }"

      merge_options o, -> merger do
        merger.add(Headless::CLI::Option.on( '-h', '--help', 'this screen.' ) do
          @queue_a << :help
        end )
      end

      o
    end

    def full_program_name
      $PROGRAM_NAME
    end

    def local_plugin_moniker  # - because we add self to merged o.p
      program_name
    end

    def action_names
      @action_names ||= action_a.map( & :slug )
    end

    # `action_a` - this is where we aggregate and sort the action metadata
    # from all our plugins and line it up into a neat little row (note it
    # is in a determinsistic way, to boot).

    def action_a
      if ! @action_a
        omni_a = [ ] ; unique_h = { }
        normalize_priority = Priority_Normalizer_[ 0.0, 1.0 ]
        emit_eventpoint :available_actions do |pi, action_a|
          action_a.each do |normal_i, priority_flot|
            act = Action_[ normal_i, pi, normalize_priority[ priority_flot ] ]
            taken = unique_h[ act.local_normal_name ]
            if taken
              raise Headless::Plugin::DeclarationError, "plugin #{
                }comprehension sorting conflict - name conflict with #{
                }\"#{ act.local_normal_name }\" from both #{
                }#{ pi.local_plugin_moniker } and #{
                }#{ taken.local_plugin_moniker }"
            else
              unique_h[ act.local_normal_name ] = pi
              omni_a << act
            end
          end
        end
        omni_a.sort_by!( & :priority )
        @action_a = omni_a
      end
      @action_a
    end

    Priority_Normalizer_ = -> exclusive_min_flot, exclusive_max_flot do
      without_priority_count = 0
      -> priority_x do
        if priority_x && !
          ( exclusive_min_flot < priority_x && priority_x < exclusive_max_flot )
          priority_x = nil
        end
        priority_x || ( exclusive_max_flot + ( without_priority_count += 1 ) )
      end
    end

    Action_ = ::Struct.new :local_normal_name, :client, :priority
    class Action_
      def slug
        @slug ||= local_normal_name.to_s  # important
      end
      def as_method
        @as_method ||= slug.gsub( '-', '_' ).intern
      end
    end

    def parse_any_explicit_actions_off_of_argv
      while @argv.length.nonzero?
        tok = @argv.fetch 0
        rx = /\A#{ ::Regexp.escape tok }/i
        act = @action_a.detect { |a| rx =~ a.slug }
        if act
          @argv.shift  # (we lose the actual token used here.)
          @queue_a << act.local_normal_name
        else
          break
        end
      end
      true
    end

    def resolve_default_action_if_necessary
      if @queue_a.length.zero?  # could be shortened but meh
        name_i  = nil
        weight_flot = 0.0
        emit_eventpoint :default_action do |pi, nm_i, wt_flot|
          if wt_flot > weight_flot
            name_i, weight_flot = nm_i, wt_flot
          end
        end
        name_i && @queue_a << name_i
      end
      @queue_a.length.nonzero?
      # (result's true-ish-ness = whether we have resolved *any* action.)
    end
  end

  module Host_InstanceMethods

    # because we are crazy and we have plugins with plugins ..

  private

    # `merge_options` - comprehend over all plugins and hack an
    # aggregate option parser.

    def merge_options up_op, at_end=nil, ctx_a=nil
      ep = plugin_host_metaservices.eventpoints.fetch :available_options
      merger = Headless::CLI::Option::Merger.new ANCHORIZED_MONIKER_
      hot_plugin_a.each do |pi|
        if pi.plugin_metaservices.subscribed_to_eventpoint? ep.normal
          rec = Headless::CLI::Option::Parser::Recorder.new do |opt|
            merger.add opt, * [ * ctx_a, pi ]
          end
          pi.send ep.as_method_name, rec, ctx_a
        end
      end
      at_end and at_end[ merger ]
      merger.write up_op
      nil
    end

    ANCHORIZED_MONIKER_ = -> * cx_a do

      # for a plugin that itself has plugins, its desc lines will qualify
      # themselves multiple times without the below check #whew

      if ! cx_a.last.plugin_metastory.is_host
        a = cx_a.reduce [] do |m, client|
          m << client.local_plugin_moniker
          m
        end
        "#{ a * ' ' } plugin"
      end
    end
  end
end

Skylab::Test::CLI.new( $stdin, $stdout, $stderr ).invoke ARGV
